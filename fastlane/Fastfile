# This is the minimum version number required.
# Update this, if you use features of a newer version
fastlane_version "2.14.0"

default_platform :ios

platform :ios do

build_output = "/tmp/letgo/"
destination = "name=iPhone X"

before_all do
	ENV["LG_GITHUB_REPOSITORY"] = "letgoapp/letgo-ios"
	# Forcing fastlane to launch simulator before all as a first step.
	ENV["FASTLANE_EXPLICIT_OPEN_SIMULATOR"] = "2"
end

desc "Will clone master, create a new `release-x.x.x` branch from, update the build info, push it and do a deploy of that to crashlytics"
lane :release do
	lg_dependencies
	base_branch_name = "master"
	Actions.lane_context[SharedValues::RB_INFO_BRANCH_NAME] = "master"
	Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER] = "tmp_lane_git_clone_folder"

	rb_info_collector(ask_for_version_number: true)

	message = "Crafting brand new version (#{ Actions.lane_context[Actions::SharedValues::RB_INFO_VERSION_NUMBER]})"
	channels = [ENV["BENDER_SLACK_DEFAULT_CHANNEL"]]
	bender(message: message, channels: channels)

	# Clone master branch
	rb_git_clone(branch_name: base_branch_name)

	# Create locally and remotely the new release branch 'release-x.x.x'
	# This will update the ENV  RB_INFO_BRANCH_NAME to the new created branch
	rb_git_create_branch(
		branch_name: "release-" + Actions.lane_context[Actions::SharedValues::RB_INFO_VERSION_NUMBER],
		repository_path: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER]
	)

	deploy_to_crashlitycs
end

desc "Will clone the specified branch, update the build info and do a deploy of that to crashlytics"
lane :beta do
	lg_dependencies

	rb_info_collector(
		ask_for_branch_name: true,
		ask_for_version_number: true,
	)

	version_number = Actions.lane_context[Actions::SharedValues::RB_INFO_VERSION_NUMBER]
	
	channels = [ENV["BENDER_SLACK_DEFAULT_CHANNEL"]]	
	bender(message:"Crafting beta (#{version_number}) 🚀  \n It's gonna be a tough ride", channels:channels)

	rb_git_clone(
		branch_name: Actions.lane_context[Actions::SharedValues::RB_INFO_BRANCH_NAME],
		shallow_clone: true
	)

	lg_update_cars_info
	lg_update_taxonomies
	lg_strings(repository_path: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER] + "/")

	deploy_to_crashlitycs
end

desc "Build and distribute build to Crashlytics"
private_lane :deploy_to_crashlitycs do
	# Update version and build numbers in info.plist (locally)
	# Custom for letgo: will also update the ios-prod.json and ios-devel.json with the new build_number
	rb_update_app_version(
		branch_name: Actions.lane_context[Actions::SharedValues::RB_INFO_BRANCH_NAME],
		version_number: Actions.lane_context[Actions::SharedValues::RB_INFO_VERSION_NUMBER],
		repository_path: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER],
		update_json_files: true,
		autoincrement: true
	)  

	version_number = Actions.lane_context[Actions::SharedValues::RB_INFO_VERSION_NUMBER]
	build_number = Actions.lane_context[SharedValues::RB_BUILD_NUMBER]
	repository_path = Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER]

	add_version_badge version_number:version_number, build_number:build_number

	gym(
		workspace: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER] + "/" + ENV["LETGO_WORKSPACE"],
		output_directory: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER],
		configuration: "Adhoc",
		scheme: "LetGoPROD",
		silent: false,
		clean: true,
		export_xcargs: "-allowProvisioningUpdates",
		export_method: "ad-hoc"
	)

	changelog = "Beta #{version_number}-#{build_number}"
	crashlytics(
		api_token: 'da82303e33e3a2dc304cdccaa4e19dba00334a34',
		build_secret: '964f1bd4540dbfa7d78d93439cf95e216ec156e046a4e46db36778084770ebbe',
		notes: "#{changelog}",
		groups: "letgo-testers"
	)

	# Update the next version number in remote branch
	lg_push(
		repository_path: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER],
		version_number: version_number,
		build_number: build_number
	)
	rb_git_clone_clean()

	message = "New beta (#{version_number} - #{build_number}) ready @here :tada:"
	bender message: message, channels: [ENV["BENDER_SLACK_DEFAULT_CHANNEL"]]
end

desc "Deploys a new version to App Store"
lane :deploy_to_appstore do
	UI.important ("\n\n ⚠️ \nThis lane will build release-x-x-x branch and send it to Apple. \n\n")
	UI.message ("📝  Before we begin...").cyan
	UI.important ("Remember to merge this branch to master after uploading to the appstore via pull request.")

	release_branch = ask("Release branch to deploy (release-x.x.x): ".yellow)
	channels = [ENV["BENDER_SLACK_DEFAULT_CHANNEL"]] 
	bender(message: "Calling Tim Cook for App Store deployment (#{release_branch})", channels: channels)
	rb_git_clone(
		branch_name: release_branch,
		clone_single_branch: false,
		shallow_clone: false
	)
	lg_fetch_app_version(
		branch_name: release_branch,
		repository_path: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER]
	)

	build_number = Actions.lane_context[Actions::SharedValues::LG_BUILD_NUMBER]
	version_number = Actions.lane_context[Actions::SharedValues::LG_VERSION_NUMBER]
	
	workspace = Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER] + "/" + ENV["LETGO_WORKSPACE"] 
	xcclean(
		workspace: workspace,
		scheme: ENV["LETGO_APPSTORE_SCHEME"]
	)

	gym(
		workspace: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER] + "/" + ENV["LETGO_WORKSPACE"],
		output_directory: Actions.lane_context[Actions::SharedValues::RB_GIT_CLONE_TMP_FOLDER],
		scheme: ENV["LETGO_APPSTORE_SCHEME"],
		configuration: "Release",
		export_xcargs: "-allowProvisioningUpdates",
		include_bitcode: true
	)

	tag_release(tag_name: version_number, build_number: build_number)
	# # Send release to itunes connect
	deliver(
		username: "ios-automation@letgo.com",
		app: "986339882",
		skip_screenshots: true,
		skip_metadata: true,
		phased_release: true,
		force: true,  # Set to true to skip PDF verification
		submit_for_review: true,
		automatic_release: false,
		submission_information: {
			export_compliance_encryption_updated: false,
			add_id_info_uses_idfa: true,
			add_id_info_serves_ads: false,
			add_id_info_tracks_install: true,
			add_id_info_tracks_action: true
		}
	)

	rb_git_clone_clean()
	bender(message: "Tim says everything okay. New Version uploaded to iTunes Connect: #{release_branch}", channels: [ENV["BENDER_SLACK_DEFAULT_CHANNEL"]])
	update_dsyms(version: version_number, build_number: build_number)
	bender(message: "Uploaded dsyms to fabric.", channels:[ENV["BENDER_SLACK_DEFAULT_CHANNEL"]])
end

desc "Will update Web Translate It with the new validated strings from google drive, download all the changes from wti and generate all not-yet valid strings on base + localizables file"
lane :strings do
	lg_strings(repository_path: "./", mark_unused_strings: false)
end

desc "Updates strings with wti and cleans un-used ones, then removes the un-used keys from code"
lane :strings_clean do
	lg_strings(repository_path: "./", remove_unused_strings: true)
	lg_strings(repository_path: "./")
end

desc "Clean un-used assets"
lane :assets_clean do
	lg_assets(repository_path: "./")
end

desc "Clean project"
lane :clean do
	# update strings and remove un-used ones
	lg_strings(repository_path: "./", remove_unused_strings: true)
	# update strings
	lg_strings(repository_path: "./")
	# clean assets
	lg_assets(repository_path: "./")
end

desc "Download all the given dSYM symbolication files from iTunes Connect and upload them to crashlytics."
lane :update_dsyms do |options|
	lg_fetch_app_version
	build_number = options[:build_number] ||= Actions.lane_context[Actions::SharedValues::LG_BUILD_NUMBER]
	version = options[:version] ||= Actions.lane_context[Actions::SharedValues::LG_VERSION_NUMBER]
   
	binary_path = "com.letgo.ios-#{version}-#{build_number}.dSYM.zip"
	download_dsyms(version: version, build_number: build_number)
	upload_symbols_to_crashlytics(
		binary_path: '/Applications/Fabric.app/Contents/MacOS/upload-symbols',
		api_token: 'da82303e33e3a2dc304cdccaa4e19dba00334a34'
	)
	clean_build_artifacts
end

private_lane :add_version_badge do |options|
	shield = "#{options[:version_number]}-#{options[:build_number]}-blue"
	path_to_repo = options[:path] ||= '.' # by default it will search in all the folders

	# glob is a parameter we got from the script https://github.com/HazAT/badge/blob/master/lib/badge/runner.rb
	add_badge(shield: shield, 
				dark: true, 
				shield_gravity: "South", 
				no_badge: true,
				glob: "/#{path_to_repo}/**/*.appiconset/*.{png,PNG}")
end

desc "Will make bender speak inside slack"
private_lane :bender do |options|
	message = options[:message]
	channels = options[:channels]
	channels.each do |channel|
	slack(
		message: message,
		success: defined?(options[:success]) ? options[:success] : true,
		channel: channel,
		default_payloads: [],
		icon_url: "https://cdn.iconscout.com/public/images/icon/premium/png-512/bender-robot-bot-technology-machine-34fbb8f5bb91b753-512x512.png"
		)
	end
end

desc "Will generate BumperFlags.switf based on the sources json"
lane :bumper do
	lg_bumper(
		source_json: "./Ambatana/src/Application/bumper_features.json",
		destination_dir: "./Ambatana/src/Manager/FeatureFlags/"
	)
end

desc "Will unit test"
lane :test do
	scan(
		scheme: "LetGoPROD",
		device: "iPhone 6",
		output_style: "rspec",
		output_directory: "./scanresults",
		output_types: "junit,html",
		clean: true,
		skip_slack: true,
		code_coverage: true
	)
end

desc "Will run CI on Jenkins"
lane :ciJenkins do
	pullRequest = ENV["BRANCH_NAME"].gsub(/[P­R-]/,'')
	puts pullRequest
	lg_github_status(
		gh_pull_request: pullRequest,
		gh_status_finished: false
	)
	testException = nil
	begin
		test
	rescue => ex
		testException = ex
	end
	lg_github_status(
		gh_pull_request: pullRequest,
		gh_status_finished: true,
		scan_results_junit: "./scanresults/report.junit",
		scan_results_url: ENV["GITHUB_STATUS_DETAIL"]
	)
	if testException
		raise testException
	end
end

desc "Will run CI unit tests job"
lane :ci do
	pullRequest = nil
	if !ENV["TEAMCITY_BRANCH"].nil?
		pullRequest = ENV["TEAMCITY_BRANCH"].sub('/merge', '')
	end

	lg_github_status(
		gh_pull_request: pullRequest,
		gh_status_finished: false
	)

	testException = nil
	begin
		test
	rescue => ex
		testException = ex
	end

	lg_github_status(
		gh_pull_request: pullRequest,
		gh_status_finished: true,
		scan_results_junit: "./scanresults/report.junit",
		scan_results_url: ENV["GITHUB_STATUS_DETAIL"]
	)
	if testException
		raise testException
	end
end

desc "Will run CI UI tests job"
lane :ci_ui_tests do
	testException = nil
	begin
		ui_test
	rescue => ex
		testException = ex
	end

	junitResult = "../scanresults/report.junit"

	message = "UI Tests - "
	success = false

	if junitResult.nil?
		message += "No results file provided!"
	elsif !File.file?(junitResult)
		message += "No results file found!"
	end

	hashResult = Crack::XML.parse(File.read(junitResult))
	tests = hashResult['testsuites']['tests']
	failures = hashResult['testsuites']['failures']

	if failures.to_i == 0
		message += "All #{tests} UI tests passed! :tada:"
		success = true
	else
		message += "Failed #{failures} UI tests from a total of #{tests} :warning:"
	end

	bender message: message, channels: [ENV["BENDER_SLACK_DEFAULT_CHANNEL"]]
	if testException
		raise testException
	end
end

lane :dependencies do
	lg_dependencies(lg_just_info: false)
end

desc "Tags current branch and pushes to remote"
private_lane :tag_release do |options|
	add_git_tag(
		tag: options[:tag_name],
		build_number: options[:build_number],
		force: true
	)
	push_git_tags(
		tag: options[:tag_name],
		remote: "origin"
	)
end

desc "Builds LetgoGoDev for simulator to export it for automation process"
lane :make_automation_build do
	timestamp = make_timestamp()
	output = "/tmp/xcbuild" + timestamp
	message = 'Hey, your .app is waiting for you. Zipped in your desktop (I am talking to whoever runned the command). #hastaluego'
	xcbuild(
		workspace: ENV["LETGO_WORKSPACE"],
		scheme: "LetGoDEV",
		configuration: "Debug",
		sdk: "iphonesimulator",
		destionation: "name=iPhone 7,OS=10.2",
		derivedDataPath: output,
		buildlog_path: "build.log"
	)
	zipped_output = "~/Desktop/automation" + timestamp + ".zip"
	sh("zip -r #{zipped_output} #{output}") 
	bender message: message, channels: [ENV["SLACK_IOS_CORE_CHANNEL"]]    
end

after_all do |lane|
	notification(
		title: "Fastlane '#{lane}'",
		message: "finished successfully"
	)
end

error do |lane, exception|
	notification(
		title: "Fastlane '#{lane}'",
		message: "Failed: #{exception.message}"
	)
	UI.error "exception: #{exception.message}"
end

# Better lanes, better future.
# We code because we care.

desc "Increases build number by 1 (unless a build number is passed) & leaves the version number still (unless a version is passed)"
lane :update_version_and_build do |options|
	repository_path = options[:repository_path] ||= '.' 

	lg_fetch_app_version(
		branch_name: options[:branch_name],
		repository_path: repository_path
	)

	build_number = options[:build_number] ||= Actions.lane_context[Actions::SharedValues::LG_BUILD_NUMBER].to_i + 1 
	version_number = options[:version_number] ||= Actions.lane_context[Actions::SharedValues::LG_VERSION_NUMBER]

	rb_update_app_version(
		branch_name: options[:branch_name],
		version_number: version_number.to_s,
		repository_path: repository_path,
		update_json_files: true,
		build_number: build_number.to_s
	)
end

desc "Creates a new minor release branch"
lane :release_minor do
	lg_fetch_app_version # This populates two env variables with the new_build & new_version
	new_version = Gem::Version.new(Actions.lane_context[Actions::SharedValues::LG_VERSION_NUMBER]).bump.to_s + '.0'
	new_build = Actions.lane_context[Actions::SharedValues::LG_BUILD_NUMBER].to_i + 1
	
	release_beta(
		new_version: new_version,
		new_build: new_build,
		base_branch: 'master'
	)
end

desc "Creates a new patch from the last tag"
lane :release_patch do |options|
	lg_dependencies
	lg_fetch_app_version # This populates two env variables with the new_build & new_version
	
	current_version = Actions.lane_context[Actions::SharedValues::LG_VERSION_NUMBER]
	
	segments = Gem::Version.new(current_version).segments
	patch = segments[2].to_i + 1
	new_version = Gem::Version.new(segments[0].to_s + "." + segments[1].to_s + "." + patch.to_s).to_s
	new_build = options[:new_build] ||= Actions.lane_context[Actions::SharedValues::LG_BUILD_NUMBER].to_i + 1

	release_beta(
		new_version: new_version,
		new_build: new_build,
		base_branch: current_version
	)
end

desc "Generates a new beta"
lane :release_beta do |options|
	lg_dependencies
	
	repository_path = 'tmp_lane_git_clone_folder'

	lg_fetch_app_version # This populates two env variables with the new_build & new_version
	new_version = options[:new_version] ||= Actions.lane_context[Actions::SharedValues::LG_VERSION_NUMBER]
	new_build = options[:new_build] ||= Actions.lane_context[Actions::SharedValues::LG_BUILD_NUMBER].to_i + 1

	message = "Crafting brand new version (#{new_version} - #{new_build})"
	channels = [ENV["BENDER_SLACK_DEFAULT_CHANNEL"]]
	bender(message: message, channels: channels)

	release_branch = 'release-' + new_version.to_s
		
	if !options[:base_branch].nil?
		base_branch_name = release_branch
		rb_git_clone(branch_name: options[:base_branch])
		# This will update the ENV RB_INFO_BRANCH_NAME to the new created branch
		rb_git_create_branch(
			branch_name: "release-" + new_version,
			repository_path: repository_path
		)
	else
		release_branch = sh("git symbolic-ref HEAD --short").gsub("\n")
		if !release_branch.include?('release') 
			UI.user_error!("You must be in a release branch")
		end
		rb_git_clone(branch_name: release_branch)    
		base_branch_name = release_branch
	end
	
	lg_fetch_app_version(
		branch_name: base_branch_name,
		repository_path: repository_path
	)
	
	update_version_and_build(
		branch_name: base_branch_name,
		repository_path: repository_path, 
		version_number: new_version.to_s, 
		build_number: new_build.to_s
	)

	add_version_badge(
		version_number: new_version.to_s, 
		build_number: new_build.to_s,
		path: repository_path
	)

	workspace = repository_path + "/" + ENV["LETGO_WORKSPACE"]
	scheme = ENV["LETGO_PROD_SCHEME"]
	build_beta(workspace: workspace, scheme: scheme)
	
	ipa_path = ENV["LG_LAST_BETA"]
	upload_crashlytics(
		beta_path: ipa_path, 
		version_number: new_version.to_s, 
		build_number: new_build.to_s
	)

	lg_push(
		repository_path: repository_path,
		version_number: new_version.to_s,
		build_number: new_build.to_s
	)
	rb_git_clone_clean()
	success = "Okey the new beta (#{new_version} - #{new_build}) is in crashlytics. Thanks for nothing. Oh my god I need a beer🍻"
	bender(message: success, channels: channels)
end
	
desc "Upload build to appstore"
lane :upload_appstore do |options|
	ipa_path = options[:ipa] ||= ENV['LAST_APPSTORE_BUILD']
	
	deliver(
		username: "ios-automation@letgo.com",
		app: "986339882",
		skip_screenshots: true,
		skip_metadata: true,
		force: true,  # Set to true to skip PDF verification
		submit_for_review: true,
		automatic_release: false,
		ipa: ipa_path,
		submission_information: {
			export_compliance_encryption_updated: false,
			add_id_info_uses_idfa: true,
			add_id_info_serves_ads: false,
			add_id_info_tracks_install: true,
			add_id_info_tracks_action: true
		}
	)
end
	
desc "Upload beta build to crashlytics"
lane :upload_crashlytics do |options|
	repository_path = options[:repository_path] ||= '.'
	lg_fetch_app_version(
		branch_name: options[:branch_name],
		repository_path: repository_path
	)
	
	ipa_path = options[:beta_path] ||= ENV['LAST_BETA_BUILD']
	version_number = options[:version_number] ||= Actions.lane_context[Actions::SharedValues::LG_VERSION_NUMBER]
	build_number = options[:build_number] ||= Actions.lane_context[Actions::SharedValues::LG_BUILD_NUMBER]
			
	changelog = "Beta #{version_number}-#{build_number}"
	crashlytics(
		api_token: 'da82303e33e3a2dc304cdccaa4e19dba00334a34',
		build_secret: '964f1bd4540dbfa7d78d93439cf95e216ec156e046a4e46db36778084770ebbe',
		ipa_path: ipa_path,
		notes: "#{changelog}",
		groups: "letgo-testers"
    )
end
	
# Here there are our 3 ways of building staff (simulator, beta, appstore)

desc "Does a beta build"
lane :build_beta do |options|
	workspace = options[:workspace] ||= ENV['LETGO_WORKSPACE']
	scheme = options[:scheme] ||= 'LetGoPROD'
	
	timestamp = make_timestamp()
	output = build_output + "/beta/#{timestamp}"
	gym(
		workspace: workspace,
		output_directory: output,
		configuration: "Adhoc",
		scheme: scheme,
		silent: false,
		clean: true,
		export_xcargs: "-allowProvisioningUpdates",
		export_method: "ad-hoc"
	)
	ENV['LAST_BETA_BUILD'] = output 	
end

desc "Does an appstore build"
lane :build_appstore do |options|
	timestamp = make_timestamp()
	workspace = options[:workspace] ||= ENV["LETGO_WORKSPACE"] 
	output = build_output + "/store/#{timestamp}"
	gym(
		workspace: workspace,
		output_directory: output,
		scheme: ENV["LETGO_APPSTORE_SCHEME"],
			configuration: "Release",
			export_xcargs: "-allowProvisioningUpdates",
			include_bitcode: true
		)	
	ENV['LAST_APPSTORE_BUILD'] = output  
end 

desc "Does a simulator build"
lane :build_sim do |options|
	workspace = options[:workspace] ||= ENV["LETGO_WORKSPACE"]
	scheme = options[:scheme] ||= "LetGoPROD"

	timestamp = make_timestamp()
 	output = build_output + "simulator/#{timestamp}"
	gym(
		workspace: workspace,
		scheme: scheme,
		configuration: "Debug",
		sdk: "iphonesimulator",
		derivedDataPath: output
	)
	ENV['LAST_SIM_BUILD'] = output
end
end

## Functions

def make_timestamp()
	Time.now.getutc.strftime("_%m_%d_%y_%I_%M_%p")
end
