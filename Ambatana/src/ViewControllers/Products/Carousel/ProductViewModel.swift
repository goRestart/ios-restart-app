//
//  ProductViewModel.swift
//  LetGo
//
//  Created by Albert Hernández López on 12/08/15.
//  Copyright (c) 2015 Ambatana. All rights reserved.
//

import CoreLocation
import FBSDKShareKit
import LGCoreKit
import Result
import RxSwift


protocol ProductViewModelDelegate: class, BaseViewModelDelegate {
    func vmShowShareFromMain(_ socialMessage: SocialMessage)
    func vmShowShareFromMoreInfo(_ socialMessage: SocialMessage)

    func vmOpenMainSignUp(_ signUpVM: SignUpViewModel, afterLoginAction: @escaping () -> ())

    func vmOpenStickersSelector(_ stickers: [Sticker])

    func vmOpenPromoteProduct(_ promoteVM: PromoteProductViewModel)
    func vmOpenCommercialDisplay(_ displayVM: CommercialDisplayViewModel)
    func vmAskForRating()
    func vmShowOnboarding()
    func vmShowProductDelegateActionSheet(_ cancelLabel: String, actions: [UIAction])

    func vmShareDidFailedWith(_ error: String)
    func vmViewControllerToShowShareOptions() -> UIViewController

    // Bump Up
    func vmShowFreeBumpUpView()
    func vmShowPaymentBumpUpView()
    func vmResetBumpUpBannerCountdown()
}


enum ProductViewModelStatus {
    
    // When Mine:
    case pending
    case pendingAndCommercializable
    case available
    case availableAndCommercializable
    case availableFree
    case sold
    case soldFree

    // Other Selling:
    case otherAvailable
    case otherAvailableFree
    case otherSold
    case otherSoldFree

    // Common:
    case notAvailable
}

fileprivate extension ProductStatus {
    var isBumpeable: Bool {
        switch self {
        case .approved:
            return true
        case .pending, .discarded, .sold, .soldOld, .deleted:
            return false
        }
    }
}

class ProductViewModel: BaseViewModel {

    // Delegate
    weak var delegate: ProductViewModelDelegate?
    weak var navigator: ProductDetailNavigator?

    // Data
    let product: Variable<Product>
    fileprivate let commercializers: Variable<[Commercializer]?>
    fileprivate let isReported = Variable<Bool>(false)
    let isFavorite = Variable<Bool>(false)
    let viewsCount = Variable<Int>(0)
    let favouritesCount = Variable<Int>(0)
    let socialMessage = Variable<SocialMessage?>(nil)
    let socialSharer: SocialSharer

    // UI - Output
    let thumbnailImage: UIImage?

    let directChatMessages = CollectionVariable<ChatViewMessage>([])

    let navBarButtons = Variable<[UIAction]>([])
    let actionButtons = Variable<[UIAction]>([])
    let directChatEnabled = Variable<Bool>(false)
    var directChatPlaceholder: String {
        let userName = product.value.user.name?.toNameReduced(maxChars: Constants.maxCharactersOnUserNameChatButton) ?? ""
        return LGLocalizedString.productChatWithSellerNameButton(userName)
    }
    fileprivate let productIsFavoriteable = Variable<Bool>(false)
    let favoriteButtonState = Variable<ButtonState>(.enabled)
    let editButtonState = Variable<ButtonState>(.hidden)
    let shareButtonState = Variable<ButtonState>(.hidden)
    let productStatusBackgroundColor = Variable<UIColor>(UIColor.black)
    let productStatusLabelText = Variable<String?>(nil)
    let productStatusLabelColor = Variable<UIColor>(UIColor.white)

    let productImageURLs = Variable<[URL]>([])

    let productTitle = Variable<String?>(nil)
    let productPrice = Variable<String>("")
    let productTitleAutogenerated = Variable<Bool>(false)
    let productTitleAutoTranslated = Variable<Bool>(false)
    let productDescription = Variable<String?>(nil)
    let productAddress = Variable<String?>(nil)
    let productLocation = Variable<LGLocationCoordinates2D?>(nil)
    let productDistance = Variable<String?>(nil)
    let productCreationDate = Variable<Date?>(nil)

    let ownerId: String?
    let ownerName: String
    let ownerAvatar: URL?
    let ownerAvatarPlaceholder: UIImage?
    
    let status = Variable<ProductViewModelStatus>(.pending)
    fileprivate let productHasReadyCommercials = Variable<Bool>(false)
    var commercializerAvailableTemplatesCount: Int? = nil

    let statsViewVisible = Variable<Bool>(false)

    let stickersButtonEnabled = Variable<Bool>(false)
    fileprivate var selectableStickers: [Sticker] = []

    let bumpUpBannerInfo = Variable<BumpUpInfo?>(nil)
    var timeSinceLastBump: Int = 0
    var bumpUpPurchaseableProduct: PurchaseableProduct?
    var paymentItemId: String?

    fileprivate var alreadyTrackedFirstMessageSent: Bool = false
    fileprivate static let bubbleTagGroup = "favorite.bubble.group"

    // UI - Input
    let moreInfoState = Variable<MoreInfoState>(.hidden)

    // Repository, helpers & tracker
    let trackHelper: ProductVMTrackHelper

    fileprivate let myUserRepository: MyUserRepository
    fileprivate let productRepository: ProductRepository
    fileprivate let commercializerRepository: CommercializerRepository
    fileprivate let chatWrapper: ChatWrapper
    fileprivate let stickersRepository: StickersRepository
    fileprivate let countryHelper: CountryHelper
    fileprivate let locationManager: LocationManager
    fileprivate let chatViewMessageAdapter: ChatViewMessageAdapter
    fileprivate let bubbleManager: BubbleNotificationManager
    fileprivate let featureFlags: FeatureFlaggeable
    fileprivate let purchasesShopper: PurchasesShopper
    fileprivate var notificationsManager: NotificationsManager
    fileprivate let monetizationRepository: MonetizationRepository


    // Retrieval status
    private var relationRetrieved = false
    private var statsRetrieved = false
    private var commercialsRetrieved: Bool {
        return commercializers.value != nil
    }

    // Rx
    private let disposeBag: DisposeBag


    // MARK: - Lifecycle

    convenience init(product: Product, thumbnailImage: UIImage?, navigator: ProductDetailNavigator?) {
        let socialSharer = SocialSharer()
        let myUserRepository = Core.myUserRepository
        let productRepository = Core.productRepository
        let commercializerRepository = Core.commercializerRepository
        let countryHelper = Core.countryHelper
        let chatWrapper = ChatWrapper()
        let stickersRepository = Core.stickersRepository
        let locationManager = Core.locationManager
        let featureFlags = FeatureFlags.sharedInstance
        let notificationsManager = NotificationsManager.sharedInstance
        let monetizationRepository = Core.monetizationRepository
        self.init(myUserRepository: myUserRepository, productRepository: productRepository,
                  commercializerRepository: commercializerRepository, chatWrapper: chatWrapper,
                  stickersRepository: stickersRepository, locationManager: locationManager, countryHelper: countryHelper,
                  product: product, thumbnailImage: thumbnailImage, socialSharer: socialSharer, navigator: navigator,
                  bubbleManager: BubbleNotificationManager.sharedInstance, featureFlags: featureFlags,
                  purchasesShopper: PurchasesShopper.sharedInstance, notificationsManager: notificationsManager,
                  monetizationRepository: monetizationRepository)
    }

    init(myUserRepository: MyUserRepository, productRepository: ProductRepository,
         commercializerRepository: CommercializerRepository, chatWrapper: ChatWrapper,
         stickersRepository: StickersRepository, locationManager: LocationManager, countryHelper: CountryHelper,
         product: Product, thumbnailImage: UIImage?, socialSharer: SocialSharer, navigator: ProductDetailNavigator?,
         bubbleManager: BubbleNotificationManager, featureFlags: FeatureFlaggeable, purchasesShopper: PurchasesShopper,
         notificationsManager: NotificationsManager, monetizationRepository: MonetizationRepository) {
        self.product = Variable<Product>(product)
        self.thumbnailImage = thumbnailImage
        self.socialSharer = socialSharer
        self.myUserRepository = myUserRepository
        self.productRepository = productRepository
        self.countryHelper = countryHelper
        self.trackHelper = ProductVMTrackHelper(product: product)
        self.commercializerRepository = commercializerRepository
        self.commercializers = Variable<[Commercializer]?>(nil)
        self.chatWrapper = chatWrapper
        self.stickersRepository = stickersRepository
        self.locationManager = locationManager
        self.navigator = navigator
        self.chatViewMessageAdapter = ChatViewMessageAdapter()
        self.bubbleManager = bubbleManager
        self.featureFlags = featureFlags
        self.purchasesShopper = purchasesShopper
        self.notificationsManager = notificationsManager
        self.monetizationRepository = monetizationRepository
        let ownerId = product.user.objectId
        self.ownerId = ownerId
        let myUser = myUserRepository.myUser
        let ownerIsMyUser: Bool
        if let productUserId = product.user.objectId, let myUser = myUser, let myUserId = myUser.objectId {
            ownerIsMyUser = ( productUserId == myUserId )
        } else {
            ownerIsMyUser = false
        }
        let myUsername = myUser?.shortName
        let ownerUsername = product.user.shortName
        self.ownerName = ownerIsMyUser ? (myUsername ?? ownerUsername ?? "") : (ownerUsername ?? "")
        let myAvatarURL = myUser?.avatar?.fileURL
        let ownerAvatarURL = product.user.avatar?.fileURL
        self.ownerAvatar = ownerIsMyUser ? (myAvatarURL ?? ownerAvatarURL) : ownerAvatarURL

        if ownerIsMyUser {
            self.ownerAvatarPlaceholder = LetgoAvatar.avatarWithColor(UIColor.defaultAvatarColor,
                                                                      name: ownerUsername)
        } else {
            self.ownerAvatarPlaceholder = LetgoAvatar.avatarWithID(ownerId, name: ownerUsername)
        }

        self.disposeBag = DisposeBag()

        super.init()

        socialSharer.delegate = self
        setupRxBindings()
    }
    
    internal override func didBecomeActive(_ firstTime: Bool) {
        guard let productId = product.value.objectId else { return }

        productRepository.incrementViews(product.value, completion: nil)

        if !relationRetrieved {
            productRepository.retrieveUserProductRelation(productId) { [weak self] result in
                guard let value = result.value  else { return }
                self?.relationRetrieved = true
                self?.isFavorite.value = value.isFavorited
                self?.isReported.value = value.isReported
            }
        }

        if !statsRetrieved {
            productRepository.retrieveStats(product.value) { [weak self] result in
                guard let strongSelf = self, let stats = result.value else { return }
                strongSelf.statsRetrieved = true
                strongSelf.viewsCount.value = stats.viewsCount
                strongSelf.favouritesCount.value = stats.favouritesCount
            }
        }

        if commercializerIsAvailable && !commercialsRetrieved {
            commercializerRepository.index(productId) { [weak self] result in
                guard let value = result.value, let strongSelf = self else { return }

                if let code = strongSelf.product.value.postalAddress.countryCode {
                    let availableTemplates = strongSelf.commercializerRepository.availableTemplatesFor(value,
                                                                                                       countryCode: code)
                    strongSelf.commercializerAvailableTemplatesCount = availableTemplates.count
                    strongSelf.refreshStatus()
                }

                let readyCommercials = value.filter {$0.status == .ready }
                self?.productHasReadyCommercials.value = !readyCommercials.isEmpty
                self?.commercializers.value = value
            }
        }

        purchasesShopper.delegate = self
    }

    func syncProduct(_ completion: (() -> ())?) {
        guard let productId = product.value.objectId else { return }
        productRepository.retrieve(productId) { [weak self] result in
            if let value = result.value {
                self?.product.value = value
            }
            completion?()
        }
    }

    private func setupRxBindings() {
        
        status.asObservable().subscribeNext { [weak self] status in
            guard let strongSelf = self else { return }
            strongSelf.productStatusBackgroundColor.value = status.bgColor
            strongSelf.productStatusLabelText.value = status.string
            strongSelf.productStatusLabelColor.value = status.labelColor
            }.addDisposableTo(disposeBag)

        status.asObservable().bindNext { [weak self] status in
            guard let strongSelf = self else { return }
            strongSelf.refreshDirectChats(status)
            strongSelf.refreshActionButtons(status)
            strongSelf.directChatEnabled.value = status.directChatsAvailable
        }.addDisposableTo(disposeBag)

        isFavorite.asObservable().subscribeNext { [weak self] _ in
            self?.refreshNavBarButtons()
        }.addDisposableTo(disposeBag)

        product.asObservable().subscribeNext { [weak self] product in
            guard let strongSelf = self else { return }
            strongSelf.trackHelper.product = product

            strongSelf.setStatus(product.viewModelStatus(strongSelf.featureFlags))

            strongSelf.productIsFavoriteable.value = !product.isMine
            strongSelf.isFavorite.value = product.favorite
            strongSelf.socialMessage.value = ProductSocialMessage(product: product)
            strongSelf.productImageURLs.value = product.images.flatMap { return $0.fileURL }

            strongSelf.productTitle.value = product.title
            strongSelf.productTitleAutogenerated.value = product.isTitleAutoGenerated
            strongSelf.productTitleAutoTranslated.value = product.isTitleAutoTranslated(strongSelf.countryHelper)
            strongSelf.productDescription.value = product.description?.trim
            strongSelf.productPrice.value = product.priceString()
            strongSelf.productAddress.value = product.postalAddress.zipCodeCityString
            strongSelf.productLocation.value = product.location
            strongSelf.productDistance.value = strongSelf.distanceString(product)
            strongSelf.productCreationDate.value = product.createdAt
        }.addDisposableTo(disposeBag)

        // bumpeable product check
        product.asObservable().bindNext { [weak self] product in
            self?.updateBumpUpbannerFor(product: product)
        }.addDisposableTo(disposeBag)

        product.asObservable().bindNext { [weak self] product in
            guard let flags = self?.featureFlags else { return }
            self?.shareButtonState.value = flags.editDeleteItemUxImprovement && product.isMine ? .enabled : .hidden
            self?.editButtonState.value = !flags.editDeleteItemUxImprovement && product.isMine ? .enabled : .hidden
        }.addDisposableTo(disposeBag)

        Observable.combineLatest(viewsCount.asObservable(), favouritesCount.asObservable(), productCreationDate.asObservable()) {
                $0.0 > Constants.minimumStatsCountToShow || $0.1 > Constants.minimumStatsCountToShow || $0.2 != nil
            }.subscribeNext { [weak self] visible in
                self?.statsViewVisible.value = visible
        }.addDisposableTo(disposeBag)

        myUserRepository.rx_myUser.bindNext { [weak self] _ in
            self?.refreshStatus()
        }.addDisposableTo(disposeBag)

        productIsFavoriteable.asObservable().bindNext { [weak self] favoriteable in
            self?.favoriteButtonState.value = favoriteable ? .enabled : .hidden
        }.addDisposableTo(disposeBag)

        moreInfoState.asObservable().map { (state: MoreInfoState) in
            return state == .shown
        }.distinctUntilChanged().bindNext { [weak self] shown in
            self?.refreshNavBarButtons()
        }.addDisposableTo(disposeBag)
    }
    
    private func distanceString(_ product: Product) -> String? {
        guard let userLocation = locationManager.currentLocation?.location else { return nil }
        let distance = product.location.distanceTo(userLocation)
        let distanceString = String(format: "%0.1f %@", arguments: [distance, DistanceType.systemDistanceType().string])
        return LGLocalizedString.productDistanceXFromYou(distanceString)
    }

    private func refreshStatus() {
        setStatus(product.value.viewModelStatus(featureFlags))
    }

    private func setStatus(_ productStatus: ProductViewModelStatus) {
        if let templates = commercializerAvailableTemplatesCount {
            status.value = productStatus.setCommercializable(templates > 0 && commercializerIsAvailable)
        } else {
            status.value = productStatus
        }
    }

    private func refreshDirectChats(_ productStatus: ProductViewModelStatus) {
        stickersButtonEnabled.value = !selectableStickers.isEmpty && productStatus.directChatsAvailable
        stickersRepository.show(typeFilter: .product) { [weak self] result in
            guard let stickers = result.value else { return }
            self?.selectableStickers = stickers
            self?.stickersButtonEnabled.value = !stickers.isEmpty && productStatus.directChatsAvailable
        }
    }

    func refreshBumpeableBanner() {
        updateBumpUpbannerFor(product: product.value)
    }

    private func updateBumpUpbannerFor(product: Product) {
        guard let productId = product.objectId, product.isMine, product.status.isBumpeable,
                featureFlags.monetizationEnabled else { return }

        monetizationRepository.retrieveBumpeableProductInfo(productId: productId, completion: { [weak self] result in
            if let bumpeableProduct = result.value {
                self?.timeSinceLastBump = bumpeableProduct.countdown
                let freeItems = bumpeableProduct.paymentItems.filter { $0.provider == .letgo }
                let paymentItemsIds = bumpeableProduct.paymentItems.filter { $0.provider == .apple }.map { $0.providerItemId }
                if !paymentItemsIds.isEmpty {
                    // will be considered bumpeable ONCE WE GOT THE PRICES of the products, not before.
                    self?.purchasesShopper.productsRequestStartForProduct(productId, withIds: paymentItemsIds)
                } else if !freeItems.isEmpty {
                    self?.paymentItemId = freeItems.first?.itemId
                    self?.createBumpeableBannerFor(productId: productId, withPrice: nil, freeBumpUp: true)
                }
            }
        })
    }

    fileprivate func createBumpeableBannerFor(productId: String, withPrice: String?, freeBumpUp: Bool) {
        guard let _ = paymentItemId else { return }

        let freeBlock = { [weak self] in
            self?.delegate?.vmShowFreeBumpUpView()
        }

        let showPaymentViewBlock = { [weak self] in
            self?.delegate?.vmShowPaymentBumpUpView()
        }
        let payBumpBlock = { [weak self] in
            self?.bumpUpProduct()
        }
        let primaryBlock = freeBumpUp ? freeBlock : showPaymentViewBlock
        let buttonBlock = freeBumpUp ? freeBlock : payBumpBlock
        bumpUpBannerInfo.value = BumpUpInfo(free: freeBumpUp, timeSinceLastBump: timeSinceLastBump, price: withPrice,
                                      primaryBlock: primaryBlock, buttonBlock: buttonBlock)
    }
}


// MARK: - Public actions

extension ProductViewModel {

    func openProductOwnerProfile() {
        let data = UserDetailData.userAPI(user: product.value.user, source: .productDetail)
        navigator?.openUser(data)
    }

    func markSold() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in

            var alertActions: [UIAction] = []
            let markAsSoldAction = UIAction(interface: .text(LGLocalizedString.productMarkAsSoldConfirmOkButton),
                action: { [weak self] in
                    self?.markSold(.markAsSold)
                })
            alertActions.append(markAsSoldAction)
            self?.delegate?.vmShowAlert( LGLocalizedString.productMarkAsSoldConfirmTitle,
                message: LGLocalizedString.productMarkAsSoldConfirmMessage,
                cancelLabel: LGLocalizedString.productMarkAsSoldConfirmCancelButton,
                actions: alertActions)

            }, source: .markAsSold)
    }
    
    func markSoldFree() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
            
            var alertActions: [UIAction] = []
            let markAsSoldAction = UIAction(interface: .text(LGLocalizedString.productMarkAsSoldFreeConfirmOkButton),
                action: { [weak self] in
                    self?.markSold(.markAsSold)
                })
            alertActions.append(markAsSoldAction)
            self?.delegate?.vmShowAlert(LGLocalizedString.productMarkAsSoldFreeConfirmTitle,
                message: LGLocalizedString.productMarkAsSoldFreeConfirmMessage,
                cancelLabel: LGLocalizedString.productMarkAsSoldFreeConfirmCancelButton,
                actions: alertActions)
            
            }, source: .markAsSold)
    }

    func editProduct() {
        navigator?.editProduct(product.value) { [weak self] editedProduct in
            self?.product.value = editedProduct
        }
    }

    func shareProduct() {
        guard let socialMessage = socialMessage.value else { return }
        if moreInfoState.value == .shown {
            delegate?.vmShowShareFromMoreInfo(socialMessage)
        } else {
            delegate?.vmShowShareFromMain(socialMessage)
        }
    }

    func resell() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in

            var alertActions: [UIAction] = []
            let sellAgainAction = UIAction(interface: .text(LGLocalizedString.productSellAgainConfirmOkButton),
                action: { [weak self] in
                    self?.markUnsold()
                })
            alertActions.append(sellAgainAction)
            self?.delegate?.vmShowAlert(LGLocalizedString.productSellAgainConfirmTitle,
                message: LGLocalizedString.productSellAgainConfirmMessage,
                cancelLabel: LGLocalizedString.productSellAgainConfirmCancelButton,
                actions: alertActions)

            }, source: .markAsUnsold)
    }

    func resellFree() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
            
            var alertActions: [UIAction] = []
            let sellAgainAction = UIAction(interface: .text(LGLocalizedString.productSellAgainFreeConfirmOkButton),
                action: { [weak self] in
                    self?.markUnsold()
                })
            alertActions.append(sellAgainAction)
            self?.delegate?.vmShowAlert(LGLocalizedString.productSellAgainFreeConfirmTitle,
                message: LGLocalizedString.productSellAgainFreeConfirmMessage,
                cancelLabel: LGLocalizedString.productSellAgainFreeConfirmCancelButton,
                actions: alertActions)
            
            }, source: .markAsUnsold)
    }

    func chatWithSeller() {
        let source: EventParameterTypePage = (moreInfoState.value == .shown) ? .productDetailMoreInfo : .productDetail
        chatWithSeller(source)
    }
    
    func chatWithSeller(_ source: EventParameterTypePage) {
        trackHelper.trackChatWithSeller(source)
        navigator?.openProductChat(product.value)
    }

    func sendDirectMessage(_ text: String, isDefaultText: Bool) {
        ifLoggedInRunActionElseOpenChatSignup { [weak self] in
            if isDefaultText {
                self?.sendMessage(.periscopeDirect(text))
            } else {
                self?.sendMessage(.text(text))
            }
        }
    }

    func openVideo() {
        guard let commercializers = commercializers.value else { return }

        let readyCommercializers = commercializers.filter {$0.status == .ready }

        guard let commercialDisplayVM = CommercialDisplayViewModel(commercializers: readyCommercializers,
                                                                   productId: product.value.objectId,
                                                                   source: .productDetail,
                                                                   isMyVideo: product.value.isMine) else { return }
        delegate?.vmOpenCommercialDisplay(commercialDisplayVM)
    }

    func promoteProduct() {
        promoteProduct(.productDetail)
    }
    
    func reportProduct() {
        guard !product.value.isMine else { return }
        reportAction()
    }

    func stickersButton() {
        guard !selectableStickers.isEmpty else { return }
        delegate?.vmOpenStickersSelector(selectableStickers)
    }

    func sendSticker(_ sticker: Sticker) {
        ifLoggedInRunActionElseOpenChatSignup { [weak self] in
            self?.sendMessage(.chatSticker(sticker))
        }
    }

    func switchFavorite() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
            self?.switchFavoriteAction()
        }, source: .favourite)
    }

    func openRelatedItems() {
        trackHelper.trackMoreInfoRelatedItemsViewMore()
        navigator?.openRelatedItems(product.value, productVisitSource: .moreInfoRelated)
    }

    func openShare(_ shareType: ShareType, fromViewController: UIViewController, barButtonItem: UIBarButtonItem? = nil) {
        guard let socialMessage = socialMessage.value else { return }
        socialSharer.share(socialMessage, shareType: shareType, viewController: fromViewController, barButtonItem: barButtonItem)
    }

    func bumpUpProduct() {
        logMessage(.info, type: [.monetization], message: "TRY TO Bump with purchase: \(bumpUpPurchaseableProduct)")
        guard let purchase = bumpUpPurchaseableProduct else { return }
        purchasesShopper.requestPaymentForProduct(purchase.productIdentifier)
    }
}


// MARK: - Private
// MARK: - Commercializer

extension ProductViewModel {
    private func numberOfCommercializerTemplates() -> Int {
        guard let countryCode = product.value.postalAddress.countryCode else { return 0 }
        return commercializerRepository.templatesForCountryCode(countryCode).count
    }

    fileprivate var commercializerIsAvailable: Bool {
        return numberOfCommercializerTemplates() > 0
    }

    fileprivate func promoteProduct(_ source: PromotionSource) {
        let theProduct = product.value
        if let countryCode = theProduct.postalAddress.countryCode, let productId = theProduct.objectId {
            let themes = commercializerRepository.templatesForCountryCode(countryCode)
            let commercializersArr = commercializers.value ?? []
            guard let promoteProductVM = PromoteProductViewModel(productId: productId,
                                                                 themes: themes, commercializers: commercializersArr, promotionSource: .productDetail) else { return }
            trackHelper.trackCommercializerStart()
            delegate?.vmOpenPromoteProduct(promoteProductVM)
        }
    }
}


// MARK: - Helper Navbar

extension ProductViewModel {

    fileprivate func refreshNavBarButtons() {
        navBarButtons.value = buildNavBarButtons()
    }

    private func buildNavBarButtons() -> [UIAction] {
        var navBarButtons = [UIAction]()

        if featureFlags.editDeleteItemUxImprovement && product.value.isMine {
            navBarButtons.append(buildEditNavBarAction())
            navBarButtons.append(buildMoreNavBarAction())
        } else {
            if (moreInfoState.value == .shown) {
                if productIsFavoriteable.value {
                    navBarButtons.append(buildFavoriteNavBarAction())
                }
                navBarButtons.append(buildMoreNavBarAction())
            } else {
                navBarButtons.append(buildShareNavBarAction())
            }
        }
        return navBarButtons
    }

    private func buildFavoriteNavBarAction() -> UIAction {
        let icon = UIImage(named: isFavorite.value ? "navbar_fav_on" : "navbar_fav_off")?
            .withRenderingMode(.alwaysOriginal)
        return UIAction(interface: .image(icon, nil), action: { [weak self] in
            self?.ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
                self?.switchFavoriteAction()
                }, source: .favourite)
            }, accessibilityId: .productCarouselNavBarFavoriteButton)
    }

    private func buildEditNavBarAction() -> UIAction {
        let icon = UIImage(named: "navbar_edit")?.withRenderingMode(.alwaysOriginal)
        return UIAction(interface: .image(icon, nil), action: { [weak self] in
            self?.editProduct()
        }, accessibilityId: .productCarouselNavBarEditButton)
    }

    private func buildMoreNavBarAction() -> UIAction {
        let icon = UIImage(named: "navbar_more")?.withRenderingMode(.alwaysOriginal)
        return UIAction(interface: .image(icon, nil), action: { [weak self] in self?.showOptionsMenu() },
                        accessibilityId: .productCarouselNavBarActionsButton)
    }

    private func buildShareNavBarAction() -> UIAction {
 		if DeviceFamily.current.isWiderOrEqualThan(.iPhone6) {
            return UIAction(interface: .textImage(LGLocalizedString.productShareNavbarButton, UIImage(named:"ic_share")), action: { [weak self] in
                self?.shareProduct()
            }, accessibilityId: .productCarouselNavBarShareButton)
        } else {
            return UIAction(interface: .text(LGLocalizedString.productShareNavbarButton), action: { [weak self] in
                self?.shareProduct()
            }, accessibilityId: .productCarouselNavBarShareButton)
        }
    }


    private func showOptionsMenu() {
        var actions = [UIAction]()
        let isMine = product.value.isMine
        let isDeletable = status.value == .notAvailable ? false : isMine

        if featureFlags.editDeleteItemUxImprovement && isMine {
            actions.append(buildEditAction())
        }
        actions.append(buildShareAction())
        if productHasReadyCommercials.value {
            actions.append(buildCommercialAction())
        }
        actions.append(buildOnboardingAction())
        if !isMine {
            actions.append(buildReportAction())
        }
        if isDeletable {
            actions.append(buildDeleteAction())
        }

        delegate?.vmShowProductDelegateActionSheet(LGLocalizedString.commonCancel, actions: actions)
    }

    private func buildEditAction() -> UIAction {
        return UIAction(interface: .text(LGLocalizedString.productOptionEdit), action: { [weak self] in
            self?.editProduct()
        }, accessibilityId: .productCarouselNavBarEditButton)
    }

    private func buildShareAction() -> UIAction {
        return UIAction(interface: .text(LGLocalizedString.productOptionShare), action: { [weak self] in
            self?.shareProduct()
        }, accessibilityId: .productCarouselNavBarShareButton)
    }

    private func buildCommercialAction() -> UIAction {
        return UIAction(interface: .text(LGLocalizedString.productOptionShowCommercial), action: { [weak self] in
            self?.openVideo()
        })
    }

    private func buildReportAction() -> UIAction {
        let title = LGLocalizedString.productReportProductButton
        return UIAction(interface: .text(title), action: reportAction)
    }
    
    fileprivate func reportAction() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] () -> () in
            guard let strongSelf = self else { return }
            
            let alertOKAction = UIAction(interface: .text(LGLocalizedString.commonYes),
                action: { [weak self] in
                    self?.ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
                        self?.report()
                        }, source: .reportFraud)
                    
                })
            strongSelf.delegate?.vmShowAlert(LGLocalizedString.productReportConfirmTitle,
                message: LGLocalizedString.productReportConfirmMessage,
                cancelLabel: LGLocalizedString.commonNo,
                actions: [alertOKAction])
            }, source: .reportFraud)
    }
    
    private func buildDeleteAction() -> UIAction {
        let title = LGLocalizedString.productDeleteConfirmTitle
        return UIAction(interface: .text(title), action: { [weak self] in
            guard let strongSelf = self else { return }

            let message: String
            var alertActions = [UIAction]()
            if strongSelf.suggestMarkSoldWhenDeleting {
                message = LGLocalizedString.productDeleteConfirmMessage

                let soldAction = UIAction(interface: .text(LGLocalizedString.productDeleteConfirmSoldButton),
                    action: { [weak self] in
                        self?.markSold(.delete)
                    })
                alertActions.append(soldAction)

                let deleteAction = UIAction(interface: .text(LGLocalizedString.productDeleteConfirmOkButton),
                    action: { [weak self] in
                        self?.delete()
                    })
                alertActions.append(deleteAction)
            } else {
                message = LGLocalizedString.productDeleteSoldConfirmMessage

                let deleteAction = UIAction(interface: .text(LGLocalizedString.commonOk),
                    action: { [weak self] in
                        self?.delete()
                    })
                alertActions.append(deleteAction)
            }

            strongSelf.delegate?.vmShowAlert(LGLocalizedString.productDeleteConfirmTitle, message: message,
                cancelLabel: LGLocalizedString.productDeleteConfirmCancelButton,
                actions: alertActions)
            })
    }
    
    private func buildOnboardingAction() -> UIAction {
        let title = LGLocalizedString.productOnboardingShowAgainButtonTitle
        return UIAction(interface: .text(title), action: { [weak self] in
            KeyValueStorage.sharedInstance[.didShowProductDetailOnboarding] = false
            self?.delegate?.vmShowOnboarding()
        })
    }

    private var socialShareMessage: SocialMessage {
        return ProductSocialMessage(product: product.value)
    }

    private var suggestMarkSoldWhenDeleting: Bool {
        switch product.value.status {
        case .pending, .discarded, .sold, .soldOld, .deleted:
            return false
        case .approved:
            return true
        }
    }
}


// MARK: - Helper Action buttons

extension ProductViewModel {

    fileprivate func refreshActionButtons(_ status: ProductViewModelStatus) {
        actionButtons.value = buildActionButtons(status)
    }

    private func buildActionButtons(_ status: ProductViewModelStatus) -> [UIAction] {
        var actionButtons = [UIAction]()
        switch status {
        case .pending, .notAvailable, .otherSold, .otherSoldFree:
            break
        case .pendingAndCommercializable:
            actionButtons.append(UIAction(interface: .button(LGLocalizedString.productCreateCommercialButton, .primary(fontSize: .big)),
                action: { [weak self] in self?.promoteProduct() }))
        case .available:
            actionButtons.append(UIAction(interface: .button(LGLocalizedString.productMarkAsSoldButton, .terciary),
                action: { [weak self] in self?.markSold() }))
        case .availableAndCommercializable:
            actionButtons.append(UIAction(interface: .button(LGLocalizedString.productMarkAsSoldButton, .terciary),
                action: { [weak self] in self?.markSold() }))
            actionButtons.append(UIAction(interface: .button(LGLocalizedString.productCreateCommercialButton, .primary(fontSize: .big)),
                action: { [weak self] in self?.promoteProduct() }))
        case .sold:
            actionButtons.append(UIAction(interface: .button(LGLocalizedString.productSellAgainButton, .secondary(fontSize: .big, withBorder: false)),
                action: { [weak self] in self?.resell() }))
        case .otherAvailable, .otherAvailableFree:
            break
        case .availableFree:
            actionButtons.append(UIAction(interface: .button(LGLocalizedString.productMarkAsSoldFreeButton, .terciary),
                action: { [weak self] in self?.markSoldFree() }))
        case .soldFree:
            actionButtons.append(UIAction(interface: .button(LGLocalizedString.productSellAgainFreeButton, .secondary(fontSize: .big, withBorder: false)),
                action: { [weak self] in self?.resellFree() }))
        }
        return actionButtons
    }
}


// MARK: - Private actions

fileprivate extension ProductViewModel {
    func switchFavoriteAction() {
        
        favoriteButtonState.value = .disabled
        let currentFavoriteValue = isFavorite.value
        isFavorite.value = !isFavorite.value
        if currentFavoriteValue {
            productRepository.deleteFavorite(product.value) { [weak self] result in
                guard let strongSelf = self else { return }
                if let _ = result.value {
                    strongSelf.notificationsManager.decreaseFavoriteCounter()
                } else {
                    strongSelf.isFavorite.value = currentFavoriteValue
                }
                strongSelf.favoriteButtonState.value = .enabled
            }
        } else {
            productRepository.saveFavorite(product.value) { [weak self] result in
                guard let strongSelf = self else { return }
                if let _ = result.value {
                    self?.trackHelper.trackSaveFavoriteCompleted()
                    strongSelf.notificationsManager.increaseFavoriteCounter()
                    if RatingManager.sharedInstance.shouldShowRating {
                        strongSelf.delegate?.vmAskForRating()
                    }
                } else {
                    strongSelf.isFavorite.value = currentFavoriteValue
                }
                strongSelf.favoriteButtonState.value = .enabled
            }
            if featureFlags.favoriteWithBubbleToChat {
                navigator?.showBubble(with: favoriteBubbleNotificationData(), duration: 5)
            }
        }
    }
  
    func favoriteBubbleNotificationData() -> BubbleNotificationData {
        let action = UIAction(interface: .text(LGLocalizedString.productBubbleFavoriteButton), action: { [weak self] in
            guard let product = self?.product.value else { return }
            self?.navigator?.openProductChat(product)
        }, accessibilityId: .bubbleButton)
        let data = BubbleNotificationData(tagGroup: ProductViewModel.bubbleTagGroup,
                                          text: LGLocalizedString.productBubbleFavoriteButton,
                                          infoText: LGLocalizedString.productBubbleFavoriteText,
                                          action: action,
                                          iconURL: nil,
                                          iconImage: UIImage(named: "user_placeholder"))
        return data
    }

    func report() {
        if isReported.value {
            delegate?.vmHideLoading(LGLocalizedString.productReportedSuccessMessage, afterMessageCompletion: nil)
            return
        }
        delegate?.vmShowLoading(LGLocalizedString.productReportingLoadingMessage)

        productRepository.saveReport(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            var message: String? = nil
            if let _ = result.value {
                strongSelf.isReported.value = true
                message = LGLocalizedString.productReportedSuccessMessage
                self?.trackHelper.trackReportCompleted()
            } else if let _ = result.error {
                message = LGLocalizedString.productReportedErrorGeneric
            }
            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: nil)
        }
    }

    func delete() {
        delegate?.vmShowLoading(LGLocalizedString.commonLoading)
        trackHelper.trackDeleteStarted()

        productRepository.delete(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            var afterMessageAction: (() -> ())? = nil
            var message: String? = nil
            if let value = result.value {
                switch strongSelf.featureFlags.postAfterDeleteMode {
                case .original:
                    message = LGLocalizedString.productDeleteSuccessMessage
                case .fullScreen, .alert:
                    break
                }
                afterMessageAction = { [weak self] in
                    self?.navigator?.closeAfterDelete()
                }
                strongSelf.product.value = value
                self?.trackHelper.trackDeleteCompleted()
            } else if let _ = result.error {
                message = LGLocalizedString.productDeleteSendErrorGeneric
            }

            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: afterMessageAction)
        }
    }

    func markSold(_ source: EventParameterSellSourceValue) {
        delegate?.vmShowLoading(nil)

        productRepository.markProductAsSold(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            var markAsSoldCompletion: (()->())? = nil

            let message: String
            if let value = result.value {
                strongSelf.product.value = value
                message = strongSelf.product.value.price.free ? LGLocalizedString.productMarkAsSoldFreeSuccessMessage : LGLocalizedString.productMarkAsSoldSuccessMessage
                self?.trackHelper.trackMarkSoldCompleted(source)
                markAsSoldCompletion = {
                    if RatingManager.sharedInstance.shouldShowRating {
                        strongSelf.delegate?.vmAskForRating()
                    }
                }
            } else {
                message = LGLocalizedString.productMarkAsSoldErrorGeneric
            }
            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: markAsSoldCompletion)
        }
    }

    func markUnsold() {
        delegate?.vmShowLoading(nil)

        productRepository.markProductAsUnsold(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            let message: String
            if let value = result.value {
                strongSelf.product.value = value
                message = strongSelf.product.value.price.free ? LGLocalizedString.productSellAgainFreeSuccessMessage : LGLocalizedString.productSellAgainSuccessMessage
                self?.trackHelper.trackMarkUnsoldCompleted()
            } else {
                message = LGLocalizedString.productSellAgainErrorGeneric
            }
            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: nil)
        }
    }

    func sendMessage(_ type: ChatWrapperMessageType) {
        // Optimistic behavior
        let message = LocalMessage(type: type, userId: myUserRepository.myUser?.objectId)
        let messageView = chatViewMessageAdapter.adapt(message)
        directChatMessages.insert(messageView, atIndex: 0)

        chatWrapper.sendMessageForProduct(product.value, type: type) {
            [weak self] result in
            if let firstMessage = result.value, let alreadyTrackedFirstMessageSent = self?.alreadyTrackedFirstMessageSent {
                self?.trackHelper.trackMessageSent(firstMessage && !alreadyTrackedFirstMessageSent,
                                                   messageType: type.chatTrackerType)
                self?.alreadyTrackedFirstMessageSent = true
            } else if let error = result.error {
                switch error {
                case .forbidden:
                    self?.delegate?.vmShowAutoFadingMessage(LGLocalizedString.productChatDirectErrorBlockedUserMessage, completion: nil)
                case .network, .internalError, .notFound, .unauthorized, .tooManyRequests, .userNotVerified, .serverError:
                    self?.delegate?.vmShowAutoFadingMessage(LGLocalizedString.chatSendErrorGeneric, completion: nil)
                }

                //Removing in case of failure
                if let indexToRemove = self?.directChatMessages.value.index(where: { $0.objectId == messageView.objectId }) {
                    self?.directChatMessages.removeAtIndex(indexToRemove)
                }
            }
        }
    }
}


// MARK: - UpdateDetailInfoDelegate

extension ProductViewModel {
    fileprivate func ifLoggedInRunActionElseOpenMainSignUp(_ action: @escaping () -> (), source: EventParameterLoginSourceValue) {
        if Core.sessionManager.loggedIn {
            action()
        } else {
            let signUpVM = SignUpViewModel(appearance: .light, source: source)
            delegate?.vmOpenMainSignUp(signUpVM, afterLoginAction: { action() })
        }
    }

    fileprivate func ifLoggedInRunActionElseOpenChatSignup(_ action: @escaping () -> ()) {
        delegate?.ifLoggedInThen(.directSticker, loginStyle: .popup(LGLocalizedString.chatLoginPopupText),
                                 loggedInAction: action, elsePresentSignUpWithSuccessAction: action)
    }
}


// MARK: - RelatedProductsViewDelegate

extension ProductViewModel: RelatedProductsViewDelegate {
    func relatedProductsView(_ view: RelatedProductsView, showProduct product: Product, atIndex index: Int,
                             productListModels: [ProductCellModel], requester: ProductListRequester,
                             thumbnailImage: UIImage?, originFrame: CGRect?) {
        trackHelper.trackMoreInfoRelatedItemsComplete(index)
        let data = ProductDetailData.productList(product: product, cellModels: productListModels, requester: requester,
                                                 thumbnailImage: thumbnailImage, originFrame: originFrame, showRelated: false, index: index)
        navigator?.openProduct(data, source: .moreInfoRelated, showKeyboardOnFirstAppearIfNeeded: false)
    }
}


// MARK: - SocialSharerDelegate

extension ProductViewModel: SocialSharerDelegate {
    func shareStartedIn(_ shareType: ShareType) {
        let buttonPosition: EventParameterButtonPosition

        switch moreInfoState.value {
        case .hidden:
            buttonPosition = .top
        case .shown, .moving:
            buttonPosition = .bottom
        }

        trackShareStarted(shareType, buttonPosition: buttonPosition)
    }

    func shareFinishedIn(_ shareType: ShareType, withState state: SocialShareState) {
        let buttonPosition: EventParameterButtonPosition

        switch moreInfoState.value {
        case .hidden:
            buttonPosition = .top
        case .shown, .moving:
            buttonPosition = .bottom
        }

        if let message = messageForShareIn(shareType, finishedWithState: state) {
            delegate?.vmShowAutoFadingMessage(message, completion: nil)
        }

        trackShareCompleted(shareType, buttonPosition: buttonPosition, state: state)
    }

    private func messageForShareIn(_ shareType: ShareType, finishedWithState state: SocialShareState) -> String? {
        switch (shareType, state) {
        case (.email, .failed):
            return LGLocalizedString.productShareEmailError
        case (.facebook, .failed):
            return LGLocalizedString.sellSendErrorSharingFacebook
        case (.fbMessenger, .failed):
            return LGLocalizedString.sellSendErrorSharingFacebook
        case (.copyLink, .completed):
            return LGLocalizedString.productShareCopylinkOk
        case (.sms, .completed):
            return LGLocalizedString.productShareSmsOk
        case (.sms, .failed):
            return LGLocalizedString.productShareSmsError
        case (_, .completed):
            return LGLocalizedString.productShareGenericOk
        default:
            break
        }
        return nil
    }
}


// MARK : - Product

extension Product {
    func viewModelStatus(_ featureFlags: FeatureFlaggeable) -> ProductViewModelStatus {
        switch status {
        case .pending:
            return isMine ? .pending : .notAvailable
        case .discarded, .deleted:
            return .notAvailable
        case .approved:
            if featureFlags.freePostingModeAllowed && price.free {
                return isMine ? .availableFree : .otherAvailableFree
            } else {
                return isMine ? .available : .otherAvailable
            }
        case .sold, .soldOld:
            if featureFlags.freePostingModeAllowed && price.free {
                return isMine ? .soldFree : .otherSoldFree
            } else {
                return isMine ? .sold : .otherSold
            }
        }
    }

    var isMine: Bool {
        let myUserId = Core.myUserRepository.myUser?.objectId
        let ownerId = user.objectId
        guard user.objectId != nil && myUserId != nil else { return false }
        return ownerId == myUserId
    }
}


// MARK: - ProductViewModelStatus

fileprivate extension ProductViewModelStatus {

    var isEditable: Bool {
        switch self {
        case .pending, .pendingAndCommercializable, .available, .availableAndCommercializable, .availableFree:
            return true
        case .notAvailable, .sold, .otherSold, .otherAvailable, .otherSoldFree, .soldFree, .otherAvailableFree:
            return false
        }
    }

    var directChatsAvailable: Bool {
        switch self {
        case .pending, .pendingAndCommercializable, .available, .availableAndCommercializable, .soldFree,
             .otherSoldFree, .availableFree, .notAvailable, .sold, .otherSold:
            return false
        case  .otherAvailable,  .otherAvailableFree:
            return true
        }
    }

    var string: String? {
        switch self {
        case .sold, .otherSold:
            return LGLocalizedString.productListItemSoldStatusLabel
        case .soldFree, .otherSoldFree:
            return LGLocalizedString.productListItemGivenAwayStatusLabel
        case .pending, .pendingAndCommercializable, .available, .availableAndCommercializable, .otherAvailable, .availableFree, .otherAvailableFree,
             .notAvailable:
            return nil
        }
    }

    var labelColor: UIColor {
        switch self {
        case .sold, .otherSold, .soldFree, .otherSoldFree:
            return UIColor.white
        case .pending, .pendingAndCommercializable, .available, .availableAndCommercializable, .otherAvailable,
             .notAvailable, .availableFree, .otherAvailableFree:
            return UIColor.clear
        }
    }

    var bgColor: UIColor {
        switch self {
        case .sold, .otherSold:
            return UIColor.soldColor
        case .soldFree, .otherSoldFree:
            return UIColor.soldFreeColor
        case .pending, .pendingAndCommercializable, .available, .availableAndCommercializable, .otherAvailable,
             .notAvailable, .availableFree, .otherAvailableFree:
            return UIColor.clear
        }
    }

    func setCommercializable(_ active: Bool) -> ProductViewModelStatus {
        switch self {
        case .pending, .pendingAndCommercializable:
            return active ? .pendingAndCommercializable : .pending
        case .available, .availableAndCommercializable:
            return active ? .availableAndCommercializable : .available
        case .sold, .otherSold, .notAvailable, .otherAvailable, .otherSoldFree, .otherAvailableFree, .soldFree, .availableFree:
            return self
        }
    }
}


// MARK: PurchasesShopperDelegate

extension ProductViewModel: PurchasesShopperDelegate {
    func shopperFinishedProductsRequestForProductId(_ productId: String?, withProducts products: [PurchaseableProduct]) {
        guard let requestProdId = productId, let currentProdId = product.value.objectId,
            requestProdId == currentProdId else { return }
        guard let purchase = products.first else { return }

        bumpUpPurchaseableProduct = purchase
        createBumpeableBannerFor(productId: requestProdId, withPrice: bumpUpPurchaseableProduct?.formattedCurrencyPrice,
                                 freeBumpUp: false)
    }

    func shopperFailedProductsRequestForProductId(_ productId: String?, withError: Error) {
        guard let requestProdId = productId, let currentProdId = product.value.objectId,
            requestProdId == currentProdId else { return }
        // update error UI
    }


    // Payment
    func freeBumpStarted() {
        delegate?.vmShowLoading(LGLocalizedString.bumpUpProcessingFreeText)
    }

    func freeBumpSuccess(withNetwork network: EventParameterShareNetwork) {
        trackHelper.trackBumpUpCompleted(.free, network: network)
        delegate?.vmHideLoading(LGLocalizedString.bumpUpFreeSuccess, afterMessageCompletion: { [weak self] in
            self?.delegate?.vmResetBumpUpBannerCountdown()
        })

    }

    func freeBumpFailed(withNetwork network: EventParameterShareNetwork) {
        delegate?.vmHideLoading(LGLocalizedString.bumpUpErrorBumpGeneric, afterMessageCompletion: nil)
    }
}
