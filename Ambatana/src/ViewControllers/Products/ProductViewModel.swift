//
//  ProductViewModel.swift
//  LetGo
//
//  Created by Albert Hernández López on 12/08/15.
//  Copyright (c) 2015 Ambatana. All rights reserved.
//

import CoreLocation
import FBSDKShareKit
import LGCoreKit
import Result
import RxSwift


protocol ProductViewModelDelegate: class, BaseViewModelDelegate {
    func vmShowNativeShare(socialMessage: SocialMessage)

    func vmOpenEditProduct(editProductVM: EditSellProductViewModel)
    func vmOpenMainSignUp(signUpVM: SignUpViewModel, afterLoginAction: () -> ())
    func vmOpenUser(userVM: UserViewModel)
    func vmOpenChat(chatVM: OldChatViewModel)
    func vmOpenWebSocketChat(chatVM: ChatViewModel)
    func vmOpenOffer(offerVC: MakeAnOfferViewController)

    func vmOpenPromoteProduct(promoteVM: PromoteProductViewModel)
    func vmOpenCommercialDisplay(displayVM: CommercialDisplayViewModel)
    func vmAskForRating()
}


enum ProductViewModelStatus {
    
    // When Mine:
    case Pending
    case PendingAndCommercializable
    case Available
    case AvailableAndCommercializable
    case Sold
    
    // Other Selling:
    case OtherAvailable
    case OtherSold
    
    // Common:
    case NotAvailable
    
    var string: String? {
        switch self {
        case .Sold, .OtherSold:
            return LGLocalizedString.productListItemSoldStatusLabel
        case .Pending, .PendingAndCommercializable, .Available, .AvailableAndCommercializable, .OtherAvailable,
             .NotAvailable:
            return nil
        }
    }
    
    var labelColor: UIColor {
        switch self {
        case .Sold, .OtherSold:
            return UIColor.whiteColor()
        case .Pending, .PendingAndCommercializable, .Available, .AvailableAndCommercializable, .OtherAvailable,
             .NotAvailable:
            return UIColor.clearColor()
        }
    }
    
    var bgColor: UIColor {
        switch self {
        case .Sold, .OtherSold:
            return StyleHelper.soldColor
        case .Pending, .PendingAndCommercializable, .Available, .AvailableAndCommercializable, .OtherAvailable,
             .NotAvailable:
            return UIColor.clearColor()
        }
    }
    
    private func setCommercializable(active: Bool) -> ProductViewModelStatus {
        switch self {
        case .Pending, .PendingAndCommercializable:
            return active ? .PendingAndCommercializable : .Pending
        case .Available, .AvailableAndCommercializable:
            return active ? .AvailableAndCommercializable : .Available
        case .Sold, .OtherSold, .NotAvailable, .OtherAvailable:
            return self
        }
    }
}

class ProductViewModel: BaseViewModel {
    // Data
    let product: Variable<Product>
    private let commercializers: Variable<[Commercializer]?>

    let thumbnailImage: UIImage?

    private let isReported = Variable<Bool>(false)
    private let isFavorite = Variable<Bool>(false)

    let viewsCount = Variable<Int>(0)
    let favouritesCount = Variable<Int>(0)

    let socialMessage = Variable<SocialMessage?>(nil)

    // Repository, helpers & tracker
    private let myUserRepository: MyUserRepository
    private let productRepository: ProductRepository
    private let commercializerRepository: CommercializerRepository
    private let chatRepository: OldChatRepository
    private let chatWebSocketRepository: ChatRepository
    private let countryHelper: CountryHelper
    private let tracker: Tracker
    private let locationManager: LocationManager

    // Delegate
    weak var delegate: ProductViewModelDelegate?

    
    // UI
    let navBarButtons = Variable<[UIAction]>([])
    let favoriteButtonEnabled = Variable<Bool>(false)
    let productStatusBackgroundColor = Variable<UIColor>(UIColor.blackColor())
    let productStatusLabelText = Variable<String?>(nil)
    let productStatusLabelColor = Variable<UIColor>(UIColor.whiteColor())

    let productImageURLs = Variable<[NSURL]>([])

    let productTitle = Variable<String?>(nil)
    let productPrice = Variable<String>("")
    let productTitleAutogenerated = Variable<Bool>(false)
    let productTitleAutoTranslated = Variable<Bool>(false)
    let productDescription = Variable<String?>(nil)
    let productAddress = Variable<String?>(nil)
    let productLocation = Variable<LGLocationCoordinates2D?>(nil)
    let productIsReportable = Variable<Bool>(true)
    let productDistance = Variable<String?>(nil)
    
    let ownerId: String?
    let ownerName: String
    let ownerAvatar: NSURL?
    let ownerAvatarPlaceholder: UIImage?
    
    let status = Variable<ProductViewModelStatus>(.Pending)
    let productHasReadyCommercials = Variable<Bool>(false)
    var commercializerAvailableTemplatesCount: Int? = nil

    let alreadyHasChats = Variable<Bool>(false)
    let askQuestionButtonTitle = Variable<String>(LGLocalizedString.productAskAQuestionButton)
    let chatWithSellerButtonTitle = Variable<String>(LGLocalizedString.productChatWithSellerButton)
    let loadingProductChats = Variable<Bool>(false)

    let statsViewVisible = Variable<Bool>(false)


    // Rx
    private let disposeBag: DisposeBag


    // MARK: - Lifecycle

    convenience init(product: Product, thumbnailImage: UIImage?) {
        let myUserRepository = Core.myUserRepository
        let productRepository = Core.productRepository
        let commercializerRepository = Core.commercializerRepository
        let chatRepository = Core.oldChatRepository
        let countryHelper = Core.countryHelper
        let tracker = TrackerProxy.sharedInstance
        let chatWebSocketRepository = Core.chatRepository
        let locationManager = Core.locationManager
        self.init(myUserRepository: myUserRepository, productRepository: productRepository,
                  commercializerRepository: commercializerRepository, chatRepository: chatRepository,
                  chatWebSocketRepository: chatWebSocketRepository, locationManager: locationManager, countryHelper: countryHelper, tracker: tracker,
                  product: product, thumbnailImage: thumbnailImage)
    }

    init(myUserRepository: MyUserRepository, productRepository: ProductRepository,
         commercializerRepository: CommercializerRepository, chatRepository: OldChatRepository,
         chatWebSocketRepository: ChatRepository, locationManager: LocationManager, countryHelper: CountryHelper,
         tracker: Tracker, product: Product, thumbnailImage: UIImage?) {
        self.product = Variable<Product>(product)
        self.thumbnailImage = thumbnailImage
        self.myUserRepository = myUserRepository
        self.productRepository = productRepository
        self.countryHelper = countryHelper
        self.tracker = tracker
        self.commercializerRepository = commercializerRepository
        self.commercializers = Variable<[Commercializer]?>(nil)
        self.chatRepository = chatRepository
        self.chatWebSocketRepository = chatWebSocketRepository
        self.locationManager = locationManager
        
        let ownerId = product.user.objectId
        self.ownerId = ownerId
        let myUser = myUserRepository.myUser
        let ownerIsMyUser: Bool
        if let productUserId = product.user.objectId, myUser = myUser, myUserId = myUser.objectId {
            ownerIsMyUser = ( productUserId == myUserId )
        } else {
            ownerIsMyUser = false
        }
        let myUsername = myUser?.shortName
        let ownerUsername = product.user.shortName
        self.ownerName = ownerIsMyUser ? (myUsername ?? ownerUsername ?? "") : (ownerUsername ?? "")
        let myAvatarURL = myUser?.avatar?.fileURL
        let ownerAvatarURL = product.user.avatar?.fileURL
        self.ownerAvatar = ownerIsMyUser ? (myAvatarURL ?? ownerAvatarURL) : ownerAvatarURL

        if ownerIsMyUser {
            self.ownerAvatarPlaceholder = LetgoAvatar.avatarWithColor(StyleHelper.defaultAvatarColor,
                                                                      name: ownerUsername)
        } else {
            self.ownerAvatarPlaceholder = LetgoAvatar.avatarWithID(ownerId, name: ownerUsername)
        }

        self.disposeBag = DisposeBag()

        super.init()

        setupRxBindings()
        
        if FeatureFlags.productDetailVersion != .Snapchat {
            trackVisit(.None)
        }
    }
    
    internal override func didBecomeActive(firstTime: Bool) {

        guard let productId = product.value.objectId else { return }

        productRepository.retrieveUserProductRelation(productId) { [weak self] result in
            guard let strongSelf = self else { return }
            if let favorited = result.value?.isFavorited, let reported = result.value?.isReported {
                strongSelf.isFavorite.value = favorited
                strongSelf.isReported.value = reported
            }
        }

        productRepository.incrementViews(product.value, completion: nil)

        productRepository.retrieveStats(product.value) { [weak self] result in
            guard let strongSelf = self else { return }
            if let stats = result.value {
                strongSelf.viewsCount.value = stats.viewsCount
                strongSelf.favouritesCount.value = stats.favouritesCount
            }
        }

        if commercializerIsAvailable {
            commercializerRepository.index(productId) { [weak self] result in
                guard let value = result.value, let strongSelf = self else { return }

                if let code = strongSelf.product.value.postalAddress.countryCode {
                    let availableTemplates = strongSelf.commercializerRepository.availableTemplatesFor(value, countryCode: code)
                    strongSelf.commercializerAvailableTemplatesCount = availableTemplates.count
                    strongSelf.status.value = strongSelf.status.value.setCommercializable(availableTemplates.count > 0)
                }

                let readyCommercials = value.filter {$0.status == .Ready }
                self?.productHasReadyCommercials.value = !readyCommercials.isEmpty
                self?.commercializers.value = value
            }
        }
    }

    private func setupRxBindings() {
        
        status.asObservable().subscribeNext { [weak self] status in
            guard let strongSelf = self else { return }
            strongSelf.productStatusBackgroundColor.value = status.bgColor
            strongSelf.productStatusLabelText.value = status.string
            strongSelf.productStatusLabelColor.value = status.labelColor
            }.addDisposableTo(disposeBag)

        product.asObservable().subscribeNext { [weak self] product in
            guard let strongSelf = self else { return }
            
            strongSelf.isFavorite.value = product.favorite
            let socialTitle = LGLocalizedString.productShareBody
            strongSelf.socialMessage.value = SocialHelper.socialMessageWithTitle(socialTitle, product: product)
            strongSelf.navBarButtons.value = strongSelf.buildNavBarButtons()
          
            let status = product.viewModelStatus
            if let templates = strongSelf.commercializerAvailableTemplatesCount {
                strongSelf.status.value = status.setCommercializable(templates > 0)
            } else {
                strongSelf.status.value = status
            }
            
            strongSelf.productStatusBackgroundColor.value = status.bgColor
            strongSelf.productStatusLabelText.value = status.string
            strongSelf.productStatusLabelColor.value = status.labelColor

            strongSelf.productImageURLs.value = product.images.flatMap { return $0.fileURL }

            strongSelf.productTitle.value = product.title
            strongSelf.productTitleAutogenerated.value = product.isTitleAutoGenerated
            strongSelf.productTitleAutoTranslated.value = product.isTitleAutoTranslated(strongSelf.countryHelper)
            strongSelf.productDescription.value = product.descr?.trim
            strongSelf.productPrice.value = product.priceString()
            strongSelf.productAddress.value = product.postalAddress.zipCodeCityString
            strongSelf.productLocation.value = product.location
            strongSelf.productIsReportable.value = !product.isMine
            strongSelf.productDistance.value = strongSelf.distanceString(product)
            }.addDisposableTo(disposeBag)

        Observable.combineLatest(viewsCount.asObservable(), favouritesCount.asObservable()) {
                $0.0 > Constants.minimumStatsCountToShow || $0.1 > Constants.minimumStatsCountToShow
            }.subscribeNext { [weak self] visible in
                self?.statsViewVisible.value = visible
        }.addDisposableTo(disposeBag)
    }
    
    private func distanceString(product: Product) -> String? {
        guard let userLocation = locationManager.currentLocation?.location else { return nil }
        let distance = product.location.distanceTo(userLocation)
        let distanceString = String(format: "%0.1f %@", arguments: [distance, DistanceType.systemDistanceType().string])
        return LGLocalizedString.productDistanceXFromYou(distanceString)
    }
}




// MARK: - Public actions

extension ProductViewModel {

    func openProductOwnerProfile() {
        guard let productOwnerId = product.value.user.objectId else { return }

        let userVM = UserViewModel(user: product.value.user, source: .ProductDetail)

        // If logged in and i'm not the product owner then open the user profile
        if Core.sessionManager.loggedIn {
            if myUserRepository.myUser?.objectId != productOwnerId {
                delegate?.vmOpenUser(userVM)
            }
        } else {
            delegate?.vmOpenUser(userVM)
        }
    }

    func openProductLocation() -> UIViewController? {
        // TODO: Refactor to return a view model as soon as ProductLocationViewController is refactored to MVVM
        let storyboard = UIStoryboard(name: "Main", bundle: nil)
        guard let vc = storyboard.instantiateViewControllerWithIdentifier("ProductLocationViewController")
            as? ProductLocationViewController else { return nil }

        let location = product.value.location
        let coordinate = CLLocationCoordinate2D(latitude: location.latitude, longitude: location.longitude)
        vc.location = coordinate
        vc.annotationTitle = product.value.name
        vc.annotationSubtitle = product.value.postalAddress.zipCodeCityString
        return vc
    }

    func markSold() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in

            var alertActions: [UIAction] = []
            let markAsSoldAction = UIAction(interface: .Text(LGLocalizedString.productMarkAsSoldConfirmOkButton),
                action: { [weak self] in
                    self?.markSold(.MarkAsSold)
                })
            alertActions.append(markAsSoldAction)
            self?.delegate?.vmShowAlert( LGLocalizedString.productMarkAsSoldConfirmTitle,
                message: LGLocalizedString.productMarkAsSoldConfirmMessage,
                cancelLabel: LGLocalizedString.productMarkAsSoldConfirmCancelButton,
                actions: alertActions)

            }, source: .MarkAsSold)
    }

    func resell() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in

            var alertActions: [UIAction] = []
            let sellAgainAction = UIAction(interface: .Text(LGLocalizedString.productSellAgainConfirmOkButton),
                action: { [weak self] in
                    self?.markUnsold()
                })
            alertActions.append(sellAgainAction)
            self?.delegate?.vmShowAlert(LGLocalizedString.productSellAgainConfirmTitle,
                message: LGLocalizedString.productSellAgainConfirmMessage,
                cancelLabel: LGLocalizedString.productSellAgainConfirmCancelButton,
                actions: alertActions)

            }, source: .MarkAsUnsold)
    }
    
    func ask(message: String?) {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
            guard let strongSelf = self else { return }
            strongSelf.openChat()
            }, source: .AskQuestion)
    }
    
    func didSelectGoToChat() {
        openChat()
    }
    
    func offer() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
            guard let strongSelf = self else { return }

            // TODO: Refactor to return a view model as soon as MakeAnOfferViewController is refactored to MVVM
            let storyboard = UIStoryboard(name: "Main", bundle: nil)
            guard let offerVC = storyboard.instantiateViewControllerWithIdentifier("MakeAnOfferViewController")
                as? MakeAnOfferViewController else { return }
            offerVC.product = strongSelf.product.value
            strongSelf.delegate?.vmOpenOffer(offerVC)
            }, source: .MakeOffer)
    }

    func sendDirectMessage(message: String?) {
        delegate?.vmShowLoading(LGLocalizedString.productChatDirectMessageSending)
        chatRepository.sendText(message ?? LGLocalizedString.productChatDirectMessage(product.value.user.name ?? ""),
                                product: product.value, recipient: product.value.user) { [weak self] result in
            if let _ = result.value {
                if let product = self?.product.value {
                    let messageType = EventParameterMessageType.Text
                    let askQuestionEvent = TrackerEvent.productAskQuestion(product, messageType: messageType,
                                                                           typePage: .ProductDetail)
                    TrackerProxy.sharedInstance.trackEvent(askQuestionEvent)
                    let messageSentEvent = TrackerEvent.userMessageSent(product, userTo: self?.product.value.user,
                                                                        messageType: messageType, isQuickAnswer: .False)
                    TrackerProxy.sharedInstance.trackEvent(messageSentEvent)
                }
                self?.alreadyHasChats.value = true

                self?.delegate?.vmHideLoading(LGLocalizedString.productChatWithSellerSendOk, afterMessageCompletion: nil)
            } else if let error = result.error {
                switch error {
                case .Forbidden:
                    self?.delegate?.vmHideLoading(LGLocalizedString.productChatDirectErrorBlockedUserMessage, afterMessageCompletion: nil)
                case .Network, .Internal, .NotFound, .Unauthorized, .TooManyRequests:
                    self?.delegate?.vmHideLoading(LGLocalizedString.chatSendErrorGeneric, afterMessageCompletion: nil)
                }
            }
        }
    }

    func openVideo() {
        guard let commercializers = commercializers.value else { return }

        let readyCommercializers = commercializers.filter {$0.status == .Ready }

        guard let commercialDisplayVM = CommercialDisplayViewModel(commercializers: readyCommercializers,
                                                                   productId: product.value.objectId,
                                                                   source: .ProductDetail,
                                                                   isMyVideo: product.value.isMine) else { return }
        delegate?.vmOpenCommercialDisplay(commercialDisplayVM)
    }

    func promoteProduct() {
        promoteProduct(.ProductDetail)
    }
    
    func reportProduct() {
        guard !product.value.isMine else { return }
        reportAction()
    }
}


// MARK: - Private
// MARK: - Chat button Actions

extension ProductViewModel {
    private func openChat() {
        if FeatureFlags.websocketChat {
            guard let sellerId = product.value.user.objectId, productId = product.value.objectId else { return }
            guard let chatVM = ChatViewModel(productId: productId, sellerId: sellerId) else { return }
            chatVM.askQuestion = .ProductDetail
            self.delegate?.vmOpenWebSocketChat(chatVM)
        } else {
            guard let chatVM = OldChatViewModel(product: product.value) else { return }
            chatVM.askQuestion = .ProductDetail
            delegate?.vmOpenChat(chatVM)
        }
    }
}


// MARK: - Commercializer

extension ProductViewModel {
    private func numberOfCommercializerTemplates() -> Int {
        guard let countryCode = product.value.postalAddress.countryCode else { return 0 }
        return commercializerRepository.templatesForCountryCode(countryCode).count
    }

    private var commercializerIsAvailable: Bool {
        return numberOfCommercializerTemplates() > 0
    }

    private func promoteProduct(source: PromotionSource) {
        let theProduct = product.value
        if let countryCode = theProduct.postalAddress.countryCode, let productId = theProduct.objectId {
            let themes = commercializerRepository.templatesForCountryCode(countryCode) ?? []
            let commercializersArr = commercializers.value ?? []
            guard let promoteProductVM = PromoteProductViewModel(productId: productId,
                                                                 themes: themes, commercializers: commercializersArr, promotionSource: .ProductDetail) else { return }

            let event = TrackerEvent.commercializerStart(theProduct.objectId, typePage: .ProductDetail)
            TrackerProxy.sharedInstance.trackEvent(event)

            delegate?.vmOpenPromoteProduct(promoteProductVM)
        }
    }
}


// MARK: - Helper

extension ProductViewModel {
    private func buildNavBarButtons() -> [UIAction] {
        var navBarButtons = [UIAction]()

        let isMine = product.value.isMine
        let isFavouritable = !isMine
        let isEditable: Bool
        let isShareable = true
        let isReportable = !isMine
        let isDeletable: Bool
        switch status.value {
        case .Pending, .PendingAndCommercializable:
            isEditable = isMine
            isDeletable = isMine
        case .Available, .AvailableAndCommercializable, .OtherAvailable:
            isEditable = isMine
            isDeletable = isMine
        case .NotAvailable:
            isEditable = false
            isDeletable = false
        case .Sold, .OtherSold:
            isEditable = false
            isDeletable = isMine
        }

        if isFavouritable {
            navBarButtons.append(buildFavoriteNavBarAction())
        }
        if isEditable {
            navBarButtons.append(buildEditNavBarAction())
        }
        if isShareable {
            navBarButtons.append(buildShareNavBarAction())
        }

        let hasMoreActions = isReportable || isDeletable
        if hasMoreActions {
            navBarButtons.append(buildMoreNavBarAction(isReportable, isDeletable: isDeletable))
        }
        return navBarButtons
    }

    private func buildFavoriteNavBarAction() -> UIAction {
        let icon = UIImage(named: isFavorite.value ? "navbar_fav_on" : "navbar_fav_off")?
            .imageWithRenderingMode(.AlwaysOriginal)
        return UIAction(interface: .Image(icon), action: { [weak self] in
            self?.ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
                self?.switchFavourite()
                }, source: .Favourite)
            })
    }

    private func buildEditNavBarAction() -> UIAction {
        let icon = UIImage(named: "navbar_edit")?.imageWithRenderingMode(.AlwaysOriginal)
        return UIAction(interface: .Image(icon), action: { [weak self] in
            guard let strongSelf = self else { return }
            let editProductVM = EditSellProductViewModel(product: strongSelf.product.value)
            strongSelf.delegate?.vmOpenEditProduct(editProductVM)
            })
    }

    private func buildShareNavBarAction() -> UIAction {
        let icon = UIImage(named: "navbar_share")?.imageWithRenderingMode(.AlwaysOriginal)
        return UIAction(interface: .Image(icon), action: { [weak self] in
            guard let strongSelf = self, socialMessage = strongSelf.socialMessage.value else { return }
            strongSelf.delegate?.vmShowNativeShare(socialMessage)
            })
    }

    private func buildMoreNavBarAction(isReportable: Bool, isDeletable: Bool) -> UIAction {
        let icon = UIImage(named: "navbar_more")?.imageWithRenderingMode(.AlwaysOriginal)
        return UIAction(interface: .Image(icon), action: { [weak self] in
            guard let strongSelf = self else { return }

            var actions = [UIAction]()
            if isReportable {
                actions.append(strongSelf.buildReportButton())
            }
            if isDeletable {
                actions.append(strongSelf.buildDeleteButton())
            }
            strongSelf.delegate?.vmShowActionSheet(LGLocalizedString.commonCancel, actions: actions)
            })
    }

    private func buildReportButton() -> UIAction {
        let title = LGLocalizedString.productReportProductButton
        return UIAction(interface: .Text(title), action: reportAction)
    }
    
    private func reportAction() {
        ifLoggedInRunActionElseOpenMainSignUp({ [weak self] () -> () in
            guard let strongSelf = self else { return }
            
            let alertOKAction = UIAction(interface: .Text(LGLocalizedString.commonYes),
                action: { [weak self] in
                    self?.ifLoggedInRunActionElseOpenMainSignUp({ [weak self] in
                        self?.report()
                        }, source: .ReportFraud)
                    
                })
            strongSelf.delegate?.vmShowAlert(LGLocalizedString.productReportConfirmTitle,
                message: LGLocalizedString.productReportConfirmMessage,
                cancelLabel: LGLocalizedString.commonNo,
                actions: [alertOKAction])
            }, source: .ReportFraud)
    }
    
    private func buildDeleteButton() -> UIAction {
        let title = LGLocalizedString.productDeleteConfirmTitle
        return UIAction(interface: .Text(title), action: { [weak self] in
            guard let strongSelf = self else { return }

            let message: String
            var alertActions = [UIAction]()
            if strongSelf.suggestMarkSoldWhenDeleting {
                message = LGLocalizedString.productDeleteConfirmMessage

                let soldAction = UIAction(interface: .Text(LGLocalizedString.productDeleteConfirmSoldButton),
                    action: { [weak self] in
                        self?.markSold(.Delete)
                    })
                alertActions.append(soldAction)

                let deleteAction = UIAction(interface: .Text(LGLocalizedString.productDeleteConfirmOkButton),
                    action: { [weak self] in
                        self?.delete()
                    })
                alertActions.append(deleteAction)
            } else {
                message = LGLocalizedString.productDeleteSoldConfirmMessage

                let deleteAction = UIAction(interface: .Text(LGLocalizedString.commonOk),
                    action: { [weak self] in
                        self?.delete()
                    })
                alertActions.append(deleteAction)
            }

            strongSelf.delegate?.vmShowAlert(LGLocalizedString.productDeleteConfirmTitle, message: message,
                cancelLabel: LGLocalizedString.productDeleteConfirmCancelButton,
                actions: alertActions)
            })
    }

    private var socialShareMessage: SocialMessage {
        let title = LGLocalizedString.productShareBody
        return SocialHelper.socialMessageWithTitle(title, product: product.value)
    }

    private var suggestMarkSoldWhenDeleting: Bool {
        switch product.value.status {
        case .Pending, .Discarded, .Sold, .SoldOld, .Deleted:
            return false
        case .Approved:
            return true
        }
    }
}


// MARK: - Private actions

extension ProductViewModel {
    private func switchFavourite() {
        favoriteButtonEnabled.value = false

        if isFavorite.value {
            productRepository.deleteFavorite(product.value) { [weak self] result in
                guard let strongSelf = self else { return }
                if let product = result.value {
                    strongSelf.product.value = product
                    strongSelf.isFavorite.value = product.favorite
                }
                strongSelf.favoriteButtonEnabled.value = true
            }
        } else {
            productRepository.saveFavorite(product.value) { [weak self] result in
                guard let strongSelf = self else { return }
                if let product = result.value {
                    strongSelf.product.value = product
                    strongSelf.isFavorite.value = product.favorite
                    self?.trackSaveFavoriteCompleted()

                    if RatingManager.sharedInstance.shouldShowRating {
                        strongSelf.delegate?.vmAskForRating()
                    }
                }
                strongSelf.favoriteButtonEnabled.value = true
            }
        }
    }

    private func report() {
        if isReported.value {
            delegate?.vmHideLoading(LGLocalizedString.productReportedSuccessMessage, afterMessageCompletion: nil)
            return
        }
        delegate?.vmShowLoading(LGLocalizedString.productReportingLoadingMessage)

        productRepository.saveReport(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            var message: String? = nil
            if let _ = result.value {
                strongSelf.isReported.value = true
                message = LGLocalizedString.productReportedSuccessMessage
                self?.trackReportCompleted()
            } else if let _ = result.error {
                message = LGLocalizedString.productReportedErrorGeneric
            }
            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: nil)
        }
    }

    private func delete() {
        delegate?.vmShowLoading(LGLocalizedString.commonLoading)
        trackDeleteStarted()

        productRepository.delete(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            var message: String? = nil
            if let value = result.value {
                strongSelf.product.value = value
                message = LGLocalizedString.productDeleteSuccessMessage
                self?.trackDeleteCompleted()
            } else if let _ = result.error {
                message = LGLocalizedString.productDeleteSendErrorGeneric
            }
            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: { () -> () in
                strongSelf.delegate?.vmPop()
            })
        }
    }

    private func markSold(source: EventParameterSellSourceValue) {
        delegate?.vmShowLoading(nil)

        productRepository.markProductAsSold(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            var markAsSoldCompletion: (()->())? = nil

            let message: String
            if let value = result.value {
                strongSelf.product.value = value
                message = LGLocalizedString.productMarkAsSoldSuccessMessage
                self?.trackMarkSoldCompleted(source)
                markAsSoldCompletion = {
                    if RatingManager.sharedInstance.shouldShowRating {
                        strongSelf.delegate?.vmAskForRating()
                    }
                }

            } else {
                message = LGLocalizedString.productMarkAsSoldErrorGeneric
            }
            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: markAsSoldCompletion)
        }
    }

    private func markUnsold() {
        delegate?.vmShowLoading(nil)

        productRepository.markProductAsUnsold(product.value) { [weak self] result in
            guard let strongSelf = self else { return }

            let message: String
            if let value = result.value {
                strongSelf.product.value = value
                message = LGLocalizedString.productSellAgainSuccessMessage
                self?.trackMarkUnsoldCompleted()
            } else {
                message = LGLocalizedString.productSellAgainErrorGeneric
            }
            strongSelf.delegate?.vmHideLoading(message, afterMessageCompletion: nil)
        }
    }
}


// MARK: - UpdateDetailInfoDelegate

extension ProductViewModel: UpdateDetailInfoDelegate {
    func updateDetailInfo(viewModel: EditSellProductViewModel, withSavedProduct savedProduct: Product) {
        product.value = savedProduct
    }

    func updateDetailInfo(viewModel: EditSellProductViewModel, withInitialProduct initialProduct: Product) {
        switch initialProduct.status {
        case .Pending:
            promoteProduct(.ProductEdit)
        case .Approved, .Discarded, .Sold, .SoldOld, .Deleted:
            break
        }
    }
}

extension ProductViewModel {
    private func ifLoggedInRunActionElseOpenMainSignUp(action: () -> (), source: EventParameterLoginSourceValue) {
        if Core.sessionManager.loggedIn {
            action()
        } else {
            let signUpVM = SignUpViewModel(source: source)
            delegate?.vmOpenMainSignUp(signUpVM, afterLoginAction: { action() })
        }
    }
}


// MARK: - Share

extension ProductViewModel {
    func shareInEmail(buttonPosition: EventParameterButtonPosition) {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .Email,
                                                     buttonPosition: buttonPosition, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInEmailCompleted() {
        let trackerEvent = TrackerEvent.productShareComplete(product.value, network: .Email,
                                                             typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInEmailCancelled() {
        let trackerEvent = TrackerEvent.productShareCancel(product.value, network: .Email, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInFacebook(buttonPosition: EventParameterButtonPosition) {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .Facebook,
                                                     buttonPosition: buttonPosition, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInFBCompleted() {
        let trackerEvent = TrackerEvent.productShareComplete(product.value, network: .Facebook,
                                                             typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInFBCancelled() {
        let trackerEvent = TrackerEvent.productShareCancel(product.value, network: .Facebook, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInFBMessenger() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .FBMessenger, buttonPosition: .Bottom,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInFBMessengerCompleted() {
        let trackerEvent = TrackerEvent.productShareComplete(product.value, network: .FBMessenger,
                                                             typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInFBMessengerCancelled() {
        let trackerEvent = TrackerEvent.productShareCancel(product.value, network: .FBMessenger,
                                                           typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInWhatsApp() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .Whatsapp, buttonPosition: .Bottom,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInTwitter() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .Twitter, buttonPosition: .Bottom,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInTwitterCompleted() {
        let trackerEvent = TrackerEvent.productShareComplete(product.value, network: .Twitter, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInTwitterCancelled() {
        let trackerEvent = TrackerEvent.productShareCancel(product.value, network: .Twitter, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }


    func shareInTelegram() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .Telegram, buttonPosition: .Bottom,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInWhatsappActivity() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .Whatsapp, buttonPosition: .Top,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInTwitterActivity() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .Twitter, buttonPosition: .Top,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInSMS() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .SMS, buttonPosition: .Bottom,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInSMSCompleted() {
        let trackerEvent = TrackerEvent.productShareComplete(product.value, network: .SMS, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInSMSCancelled() {
        let trackerEvent = TrackerEvent.productShareCancel(product.value, network: .SMS, typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }

    func shareInCopyLink() {
        let trackerEvent = TrackerEvent.productShare(product.value, network: .CopyLink, buttonPosition: .Bottom,
                                                     typePage: .ProductDetail)
        tracker.trackEvent(trackerEvent)
    }
}


// MARK: - Tracking

extension ProductViewModel {
    
    func trackVisit(visitUserAction: ProductVisitUserAction) {
        let trackerEvent = TrackerEvent.productDetailVisit(product.value, visitUserAction: visitUserAction)
        tracker.trackEvent(trackerEvent)
    }
    
    func trackVisitMoreInfo() {
        let trackerEvent = TrackerEvent.productDetailVisitMoreInfo(product.value)
        tracker.trackEvent(trackerEvent)
    }

    private func trackReportCompleted() {
        let trackerEvent = TrackerEvent.productReport(product.value)
        tracker.trackEvent(trackerEvent)
    }

    private func trackDeleteStarted() {
        let trackerEvent = TrackerEvent.productDeleteStart(product.value)
        tracker.trackEvent(trackerEvent)
    }

    private func trackDeleteCompleted() {
        let trackerEvent = TrackerEvent.productDeleteComplete(product.value)
        tracker.trackEvent(trackerEvent)
    }

    private func trackMarkSoldCompleted(source: EventParameterSellSourceValue) {
        let trackerEvent = TrackerEvent.productMarkAsSold(source, product: product.value)
        tracker.trackEvent(trackerEvent)
    }

    private func trackMarkUnsoldCompleted() {
        let trackerEvent = TrackerEvent.productMarkAsUnsold(product.value)
        tracker.trackEvent(trackerEvent)
    }

    private func trackSaveFavoriteCompleted() {
        let trackerEvent = TrackerEvent.productFavorite(product.value, typePage: .ProductDetail)
        TrackerProxy.sharedInstance.trackEvent(trackerEvent)
    }
}


// MARK : - Product

extension Product {
    private var viewModelStatus: ProductViewModelStatus {
        switch status {
        case .Pending:
            return isMine ? .Pending : .NotAvailable
        case .Discarded, .Deleted:
            return .NotAvailable
        case .Approved:
            return isMine ? .Available : .OtherAvailable
        case .Sold, .SoldOld:
            return isMine ? .Sold : .OtherSold
        }
    }

    var isMine: Bool {
        let myUserId = Core.myUserRepository.myUser?.objectId
        let ownerId = user.objectId
        guard user.objectId != nil && myUserId != nil else { return false }
        return ownerId == myUserId
    }
}
