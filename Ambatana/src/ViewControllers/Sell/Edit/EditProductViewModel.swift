//
//  EditProductViewModel.swift
//  LetGo
//
//  Created by DÃ­dac on 23/07/15.
//  Copyright (c) 2015 Ambatana. All rights reserved.
//

import FBSDKShareKit
import LGCoreKit
import Result
import RxSwift



enum TitleDisclaimerStatus {
    case completed  // title autogenerated and selected
    case ready      // no title yet, just received an autogenerated one
    case loading    // no title, waiting for response
    case clean      // user edits title
}

protocol EditProductViewModelDelegate : BaseViewModelDelegate {
    func vmShouldUpdateDescriptionWithCount(_ count: Int)
    func vmDidAddOrDeleteImage()
    func openCarsAttributesChoicesWithViewModel(attributesChoiceViewModel: CarsAttributesChoiceViewModel)
    func vmShouldOpenMapWithViewModel(_ locationViewModel: EditLocationViewModel)
    func vmShareOnFbWith(content: FBSDKShareLinkContent)
    func vmHideKeyboard()
}

enum EditProductImageType {
    case local(image: UIImage)
    case remote(file: File)
}

class ProductImages {
    var images: [EditProductImageType] = []
    var localImages: [UIImage] {
        return images.flatMap {
            switch $0 {
            case .local(let image):
                return image
            case .remote:
                return nil
            }
        }
    }
    var remoteImages: [File] {
        return images.flatMap {
            switch $0 {
            case .local:
                return nil
            case .remote(let file):
                return file
            }
        }
    }

    func append(_ image: UIImage) {
        images.append(.local(image: image))
    }

    func append(_ file: File) {
        images.append(.remote(file: file))
    }

    func removeAtIndex(_ index: Int) {
        images.remove(at: index)
    }
}

class EditProductViewModel: BaseViewModel, EditLocationDelegate {

    // real time cloudsight
    let proposedTitle = Variable<String>("")
    let titleDisclaimerStatus = Variable<TitleDisclaimerStatus>(.completed)
    fileprivate var userIsEditingTitle: Bool
    fileprivate var hasTitle: Bool {
        return (title != nil && title != "")
    }
    fileprivate var productIsNew: Bool {
        guard let creationDate = initialListing.createdAt else { return true }
        return creationDate.isNewerThan(Constants.cloudsightTimeThreshold)
    }
    fileprivate var shouldAskForAutoTitle: Bool {
        // we ask for title if the product has less than 1h (or doesn't has creation date)
        // AND doesn't has one, or the user is editing the field
        return (!hasTitle || userIsEditingTitle) && productIsNew
    }
    fileprivate var requestTitleTimer: Timer?

    // Input
    var title: String? {
        didSet {
            checkChanges()
        }
    }
    var currency: Currency?
    var price: String? {
        didSet {
            checkChanges()
        }
    }
    var postalAddress: PostalAddress?
    var location: LGLocationCoordinates2D? {
        didSet {
            checkChanges()
        }
    }
    var shouldShareInFB: Bool
    let maxImageCount = Constants.maxImageCount
    var descr: String? {
        didSet {
            checkChanges()
            delegate?.vmShouldUpdateDescriptionWithCount(descriptionCharCount)
        }
    }


    // Rx in-out
    let isFreePosting =  Variable<Bool>(false)
    let category = Variable<ListingCategory?>(nil)
    let carMakeId = Variable<String?>(nil)
    let carMakeName = Variable<String?>(nil)
    let carModelId = Variable<String?>(nil)
    let carModelName = Variable<String?>(nil)
    let carYear = Variable<Int?>(nil)

    // Rx output
    let titleAutogenerated = Variable<Bool>(false)
    let titleAutotranslated = Variable<Bool>(false)
    let locationInfo = Variable<String>("")
    let loadingProgress = Variable<Float?>(nil)
    let saveButtonEnabled = Variable<Bool>(false)

    // Data
    var productImages: ProductImages
    var images: [EditProductImageType] {
        return productImages.images
    }
    fileprivate let initialListing: Listing
    fileprivate var savedListing: Listing?
    fileprivate var categories: [ListingCategory] = []
    fileprivate var shouldTrack: Bool = true
    
    // Repositories
    let myUserRepository: MyUserRepository
    let listingRepository: ListingRepository
    let fileRepository: FileRepository
    let categoryRepository: CategoryRepository
    let carsInfoRepository: CarsInfoRepository
    let locationManager: LocationManager
    let tracker: Tracker
    let featureFlags: FeatureFlaggeable

    // Delegate
    weak var delegate: EditProductViewModelDelegate?
    var closeCompletion: ((Listing?) -> Void)?

    // Rx
    let disposeBag = DisposeBag()

    
    // MARK: - Lifecycle
    
    convenience init(listing: Listing) {
        self.init(listing: listing,
                  myUserRepository: Core.myUserRepository,
                  listingRepository: Core.listingRepository,
                  fileRepository: Core.fileRepository,
                  categoryRepository: Core.categoryRepository,
                  carsInfoRepository: Core.carsInfoRepository,
                  locationManager: Core.locationManager,
                  tracker: TrackerProxy.sharedInstance,
                  featureFlags: FeatureFlags.sharedInstance)
    }
    
    init(listing: Listing,
         myUserRepository: MyUserRepository,
         listingRepository: ListingRepository,
         fileRepository: FileRepository,
         categoryRepository: CategoryRepository,
         carsInfoRepository: CarsInfoRepository,
         locationManager: LocationManager,
         tracker: Tracker,
         featureFlags: FeatureFlaggeable) {
        self.myUserRepository = myUserRepository
        self.listingRepository = listingRepository
        self.fileRepository = fileRepository
        self.categoryRepository = categoryRepository
        self.carsInfoRepository = carsInfoRepository
        self.locationManager = locationManager
        self.tracker = tracker
        self.featureFlags = featureFlags
        self.initialListing = listing

        self.title = listing.title
        
        self.titleAutotranslated.value = listing.isTitleAutoTranslated(Core.countryHelper)
        self.titleAutogenerated.value = listing.isTitleAutoGenerated

        self.proposedTitle.value = listing.nameAuto ?? ""
        self.userIsEditingTitle = false

        self.price = listing.price.value > 0 ? String.fromPriceDouble(listing.price.value) : nil

        currency = listing.currency
        if let descr = listing.descr {
            self.descr = descr
        }

        self.postalAddress = listing.postalAddress
        self.location = listing.location

        self.locationInfo.value = listing.postalAddress.zipCodeCityString ?? ""

        self.category.value = listing.category

        self.productImages = ProductImages()
        for file in listing.images { productImages.append(file) }

        switch listing {
        case .car(let car):
            self.carMakeId.value = car.carAttributes.makeId
            self.carMakeName.value = car.carAttributes.make
            self.carModelId.value = car.carAttributes.modelId
            self.carModelName.value = car.carAttributes.model
            self.carYear.value = car.carAttributes.year
        case .product(_):
            break
        }

        self.shouldShareInFB = false
        self.isFreePosting.value = featureFlags.freePostingModeAllowed && listing.price.free
        super.init()

        setupCategories()
        setupRxBindings()
        trackStart()
    }

    override func didBecomeActive(_ firstTime: Bool) {
        super.didBecomeActive(firstTime)
        startTimer()
    }

    override func didBecomeInactive() {
        super.didBecomeInactive()
        stopTimer()
    }
    
    
    // MARK: - methods

    func closeButtonPressed() {
        if saveButtonEnabled.value {
            showCloseWChangesAlert()
        } else {
            closeEdit()
        }
    }

    var numberOfImages: Int {
        return images.count
    }
    
    func imageAtIndex(_ index: Int) -> EditProductImageType {
        return images[index]
    }
    
    var categoryName: String? {
        return category.value?.name
    }

    var carAttributes: CarAttributes {
        return CarAttributes(makeId: carMakeId.value, make: carMakeName.value, modelId: carModelId.value,
                             model: carModelName.value, year: carYear.value)
    }

    var descriptionCharCount: Int {
        guard let descr = descr else { return Constants.productDescriptionMaxLength }
        return Constants.productDescriptionMaxLength-descr.characters.count
    }
    
    func appendImage(_ image: UIImage) {
        productImages.append(image)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func deleteImageAtIndex(_ index: Int) {
        productImages.removeAtIndex(index)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func sendButtonPressed() {
        let error = validate()
        if let actualError = error {
            showError(actualError)
            trackValidationFailedWithError(actualError)
        } else {
            updateListing(listing: initialListing)
        }
    }

    func carMakeButtonPressed() {
        // open car makes table
        let carsMakesList = carsInfoRepository.retrieveCarsMakes()
        let carsAttributtesChoiceVMWithMakes = CarsAttributesChoiceViewModel(carsMakes: carsMakesList)
        carsAttributtesChoiceVMWithMakes.choiceDelegate = self
        delegate?.openCarsAttributesChoicesWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithMakes)
    }

    func carModelButtonPressed() {
        // open car models table
        guard let makeId = carMakeId.value else { return }
        let carsModelsList = carsInfoRepository.retrieveCarsModelsFormake(makeId: makeId)
        let carsAttributtesChoiceVMWithModels = CarsAttributesChoiceViewModel(carsModels: carsModelsList)
        carsAttributtesChoiceVMWithModels.choiceDelegate = self
        delegate?.openCarsAttributesChoicesWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithModels)
    }

    func carYearButtonPressed() {
        // open car years table
        guard let _ = carModelId.value else { return }
        let carsYearsList = carsInfoRepository.retrieveValidYears(withFirstYear: nil, ascending: false)
        let carsAttributtesChoiceVMWithYears = CarsAttributesChoiceViewModel(yearsList: carsYearsList)
        carsAttributtesChoiceVMWithYears.choiceDelegate = self
        delegate?.openCarsAttributesChoicesWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithYears)
    }

    var fbShareContent: FBSDKShareLinkContent? {
        if let listing = savedListing {
            return ProductSocialMessage(listing: listing, fallbackToStore: false).fbShareContent
        }
        return nil
    }

    func openMap() {
        var shouldAskForPermission = true
        var permissionsActionBlock: ()->() = {}
        // check location enabled
        switch locationManager.locationServiceStatus {
        case let .enabled(authStatus):
            switch authStatus {
            case .notDetermined:
                shouldAskForPermission = true
                permissionsActionBlock = {  [weak self] in self?.locationManager.startSensorLocationUpdates() }
            case .restricted, .denied:
                shouldAskForPermission = true
                permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
            case .authorized:
                shouldAskForPermission = false
            }
        case .disabled:
            shouldAskForPermission = true
            permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
        }

        if shouldAskForPermission {
            // not enabled
            let okAction = UIAction(interface: UIActionInterface.styledText(LGLocalizedString.commonOk,
                .standard), action: permissionsActionBlock)
            let alertIcon = UIImage(named: "ic_location_alert")
            delegate?.vmShowAlertWithTitle(LGLocalizedString.editProductLocationAlertTitle,
                                           text: LGLocalizedString.editProductLocationAlertText,
                                           alertType: .iconAlert(icon: alertIcon), actions: [okAction])
        } else {
            // enabled
            let initialPlace = Place(postalAddress: nil, location: locationManager.currentAutoLocation?.location)
            let locationVM = EditLocationViewModel(mode: .editProductLocation, initialPlace: initialPlace)
            locationVM.locationDelegate = self
            delegate?.vmShouldOpenMapWithViewModel(locationVM)
        }
    }

    func fbSharingFinishedOk() {
        shouldTrack = true
        trackSharedFB()
        delay(Constants.fbSdkRequiredDelay) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }

    func fbSharingFinishedWithError() {
        shouldTrack = true
        delay(Constants.fbSdkRequiredDelay) { [weak self] in
            self?.delegate?.vmShowAutoFadingMessage(LGLocalizedString.sellSendErrorSharingFacebook) { [weak self] in
                self?.showSuccessMessageAndClose()
            }
        }
    }

    func fbSharingCancelled() {
        shouldTrack = true
        delay(Constants.fbSdkRequiredDelay) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }


    // MARK: - Private methods

    private func startTimer() {
        guard shouldAskForAutoTitle else { return }
        requestTitleTimer = Timer.scheduledTimer(timeInterval: Constants.cloudsightRequestRepeatInterval, target: self,
                                                                   selector: #selector(getAutoGeneratedTitle),
                                                                   userInfo: nil, repeats: true)
        requestTitleTimer?.fire()
    }

    fileprivate func stopTimer() {
        requestTitleTimer?.invalidate()
    }

    private func setupRxBindings() {
        isFreePosting.asObservable().bindNext { [weak self] _ in self?.checkChanges() }.addDisposableTo(disposeBag)
        category.asObservable().bindNext { [weak self] _ in self?.checkChanges() }.addDisposableTo(disposeBag)
        carMakeName.asObservable().bindNext { [weak self] _ in self?.checkChanges() }.addDisposableTo(disposeBag)
        carModelName.asObservable().bindNext { [weak self] _ in self?.checkChanges() }.addDisposableTo(disposeBag)
        carYear.asObservable().bindNext { [weak self] _ in self?.checkChanges() }.addDisposableTo(disposeBag)
    }

    private func checkChanges() {
        var hasChanges = false
        if productImages.localImages.count > 0 || initialListing.images.count != productImages.remoteImages.count  {
            hasChanges = true
        }
        else if (initialListing.title ?? "") != (title ?? "") {
            hasChanges = true
        }
        else if initialListing.price.value != Double(price ?? "0") {
            hasChanges = true
        }
        else if (initialListing.descr ?? "") != (descr ?? "") {
            hasChanges = true
        }
        else if initialListing.category != category.value {
            hasChanges = true
        }
        else if initialListing.location != location {
            hasChanges = true
        }
        else if initialListing.price.free != isFreePosting.value {
            hasChanges = true
        }
        else if initialListing.isCar {
            hasChanges = initialListing.car?.carAttributes != carAttributes
        }
        saveButtonEnabled.value = hasChanges
    }

    private func validate() -> ProductCreateValidationError? {
        
        if images.count < 1 {
            return .noImages
        } else if descriptionCharCount < 0 {
            return .longDescription
        } else if category.value == nil {
            return .noCategory
        }
        return nil
    }

    private func updateListing(listing: Listing) {
        guard let category = category.value else {
            showError(.noCategory)
            return
        }
        switch category {
        case .unassigned, .electronics, .motorsAndAccessories, .sportsLeisureAndGames, .homeAndGarden,
             .moviesBooksAndMusic, .fashionAndAccesories, .babyAndChild, .other:
            updateProduct(listing: listing, withCategory: category)
        case .cars:
            updateCar(listing: listing)
        }
    }

    func updateProduct(listing: Listing?, withCategory category: ListingCategory) {
        guard let listing = listing else { return }
        guard let editParams = ProductEditionParams(listing: listing) else { return }
        delegate?.vmHideKeyboard()
        loadingProgress.value = 0
        editParams.category = category
        editParams.name = title ?? ""
        editParams.descr = (descr ?? "").stringByRemovingEmoji()
        editParams.price = isFreePosting.value && featureFlags.freePostingModeAllowed ? ListingPrice.free : ListingPrice.normal((price ?? "0").toPriceDouble())
        if let updatedLocation = location, let updatedPostalAddress = postalAddress {
            editParams.location = updatedLocation
            editParams.postalAddress = updatedPostalAddress
        }

        let localImages = productImages.localImages
        let remoteImages = productImages.remoteImages
        fileRepository.upload(localImages, progress: { [weak self] in self?.loadingProgress.value = $0 }) {
            [weak self] imagesResult in
            if let newImages = imagesResult.value {
                editParams.images = remoteImages + newImages
                self?.listingRepository.update(productParams: editParams) { result in
                    self?.loadingProgress.value = nil
                    if let actualProduct = result.value {
                        let responseListing = Listing.product(actualProduct)
                        self?.savedListing = responseListing
                        self?.trackComplete(responseListing)
                        self?.finishedSaving()
                    } else if let error = result.error {
                        self?.showError(ProductCreateValidationError(repoError: error))
                    }
                }
            } else if let error = imagesResult.error {
                self?.showError(ProductCreateValidationError(repoError: error))
            }
        }
    }

    func updateCar(listing: Listing?) {
        guard let listing = listing else { return }
        guard let editParams = CarEditionParams(listing: listing) else { return }
        delegate?.vmHideKeyboard()
        loadingProgress.value = 0
        editParams.carAttributes = carAttributes
        editParams.category = .cars
        editParams.name = title ?? ""
        editParams.descr = (descr ?? "").stringByRemovingEmoji()
        editParams.price = ListingPrice.normal((price ?? "0").toPriceDouble())
        if let updatedLocation = location, let updatedPostalAddress = postalAddress {
            editParams.location = updatedLocation
            editParams.postalAddress = updatedPostalAddress
        }

        let localImages = productImages.localImages
        let remoteImages = productImages.remoteImages
        fileRepository.upload(localImages, progress: { [weak self] in self?.loadingProgress.value = $0 }) {
            [weak self] imagesResult in
            if let newImages = imagesResult.value {
                editParams.images = remoteImages + newImages
                self?.listingRepository.update(carParams: editParams) { result in
                    self?.loadingProgress.value = nil
                    if let actualCar = result.value {
                        let responseListing = Listing.car(actualCar)
                        self?.savedListing = responseListing
                        self?.trackComplete(responseListing)
                        self?.finishedSaving()
                    } else if let error = result.error {
                        self?.showError(ProductCreateValidationError(repoError: error))
                    }
                }
            } else if let error = imagesResult.error {
                self?.showError(ProductCreateValidationError(repoError: error))
            }
        }
    }

    private func finishedSaving() {
        if let fbShareContent = fbShareContent, shouldShareInFB {
            shouldTrack = false
            delegate?.vmShareOnFbWith(content: fbShareContent)
        } else {
            showSuccessMessageAndClose()
        }
    }

    private func showSuccessMessageAndClose() {
        delegate?.vmShowAutoFadingMessage(LGLocalizedString.editProductSendOk) { [weak self] in
            self?.closeEdit()
        }
    }

    private func showCloseWChangesAlert() {
        let cancelAction = UIAction(
            interface: .button(LGLocalizedString.commonCancel, .secondary(fontSize: .medium, withBorder: true)),
            action: {})
        let discardAction = UIAction(
            interface: .button(LGLocalizedString.editProductUnsavedChangesAlertOk, .primary(fontSize: .medium)),
            action: { [weak self] in
                self?.closeEdit()
        })

        delegate?.vmHideKeyboard()
        delegate?.vmShowAlertWithTitle(nil, text: LGLocalizedString.editProductUnsavedChangesAlert,
                                       alertType: .plainAlert, actions: [cancelAction, discardAction])
    }

    private func closeEdit() {
        delegate?.vmHideKeyboard()
        delegate?.vmDismiss { [weak self] in
            self?.closeCompletion?(self?.savedListing)
        }
    }

    private func showError(_ error: ProductCreateValidationError) {
        var completion: ((Void) -> Void)? = nil
        if !error.isFieldError {
            shouldTrack = false
            completion = { [weak self] in self?.shouldTrack = true }
        }
        delegate?.vmShowAutoFadingMessage(error.errorMessage, completion: completion)
    }

    private func openLocationAppSettings() {
        guard let settingsURL = URL(string:UIApplicationOpenSettingsURLString) else { return }
        UIApplication.shared.openURL(settingsURL)
    }
}


// MARK: - Categories

extension EditProductViewModel {

    var numberOfCategories: Int {
        return categories.count
    }

    func categoryNameAtIndex(_ index: Int) -> String {
        guard 0..<categories.count ~= index else { return "" }
        return categories[index].name
    }

    func selectCategoryAtIndex(_ index: Int) {
        guard 0..<categories.count ~= index else { return }
        category.value = categories[index]
    }

    fileprivate func setupCategories() {
        categoryRepository.index(filterVisible: !featureFlags.carsVerticalEnabled) { [weak self] result in
            guard let categories = result.value else { return }
            self?.categories = categories
        }
    }
}


// MARK: - EditLocationDelegate

extension EditProductViewModel {
    func editLocationDidSelectPlace(_ place: Place) {
        location = place.location
        postalAddress = place.postalAddress
        locationInfo.value = place.postalAddress?.zipCodeCityString ?? ""
    }
}

// MARK: - CarsAttributesChoiceDelegate

extension EditProductViewModel : CarsAttributesChoiceDelegate {
    func didSelectMake(make: CarsMake) {
        carMakeId.value = make.makeId
        carMakeName.value = make.makeName
        carModelId.value = nil
        carModelName.value = nil
        carYear.value = nil
    }

    func didSelectModel(model: CarsModel) {
        carModelId.value = model.modelId
        carModelName.value = model.modelName
        carYear.value = nil
    }

    func didSelectYear(year: Int) {
        carYear.value = year
    }
}

// MARK: - Cloudsight in real time

extension EditProductViewModel {
    dynamic func getAutoGeneratedTitle() {
        guard let productId = initialListing.objectId, shouldAskForAutoTitle else {
            stopTimer()
            return
        }
        titleDisclaimerStatus.value = .loading
        listingRepository.retrieve(productId) { [weak self] result in
            if let value = result.value {
                guard let proposedTitle = value.nameAuto else { return }
                self?.stopTimer()
                self?.titleDisclaimerStatus.value = .ready
                self?.proposedTitle.value = proposedTitle
            }
        }
    }

    /**
     Method called when the title textfield gets the focus
     */
    func userWritesTitle(_ text: String?) {
        guard productIsNew else { return }
        userIsEditingTitle = true
        titleAutotranslated.value = false
        titleAutogenerated.value = false
        titleDisclaimerStatus.value = proposedTitle.value.isEmpty ? .loading : .ready
    }

    func userFinishedEditingTitle(_ text: String) {
        guard productIsNew else { return }
        if text.isEmpty {
            titleLeftBlank()
        } else if text == proposedTitle.value {
            titleAutotranslated.value = true
            titleAutogenerated.value = true
            titleDisclaimerStatus.value = .completed
        } else {
            titleAutotranslated.value = false
            titleAutogenerated.value = false
            titleDisclaimerStatus.value = proposedTitle.value.isEmpty ? .loading : .ready
        }
    }

    /**
     Method called when the title textfield loses the focus, and is empty
     */
    func titleLeftBlank() {
        guard productIsNew else { return }
        userIsEditingTitle = false
        titleDisclaimerStatus.value = proposedTitle.value.isEmpty ? .loading : .ready
    }

    /**
     Method called when the user presses the suggested title button
     */
    func userSelectedSuggestedTitle() {
        titleAutotranslated.value = true
        titleAutogenerated.value = true
        titleDisclaimerStatus.value = .completed
    }
}


// MARK: - Trackings

extension EditProductViewModel {

    fileprivate func trackStart() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditStart(myUser, listing: initialListing)
        trackEvent(event)
    }

    fileprivate func trackValidationFailedWithError(_ error: ProductCreateValidationError) {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditFormValidationFailed(myUser, listing: initialListing,
                                                                 description: error.description)
        trackEvent(event)
    }

    fileprivate func trackSharedFB() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditSharedFB(myUser, listing: savedListing)
        trackEvent(event)
    }

    fileprivate func trackComplete(_ listing: Listing) {
        // if nothing is changed, we don't track the edition
        let editedFields = editFieldsComparedTo(listing)
        guard !editedFields.isEmpty  else { return }

        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditComplete(myUser, listing: listing, category: category.value,
                                                     editedFields: editedFields)
        trackEvent(event)
    }

    fileprivate func trackEvent(_ event: TrackerEvent) {
        if shouldTrack {
            tracker.trackEvent(event)
        }
    }

    fileprivate func editFieldsComparedTo(_ listing: Listing) -> [EventParameterEditedFields] {
        var editedFields: [EventParameterEditedFields] = []

        if productImages.localImages.count > 0 || initialListing.images.count != productImages.remoteImages.count  {
            editedFields.append(.picture)
        }
        if (initialListing.name ?? "") != (listing.name ?? "") {
            editedFields.append(.title)
        }
        if initialListing.priceString() != listing.priceString() {
            editedFields.append(.price)
        }
        if (initialListing.descr ?? "") != (listing.descr ?? "") {
            editedFields.append(.description)
        }
        if initialListing.category != listing.category {
            editedFields.append(.category)
        }
        if initialListing.location != listing.location {
            editedFields.append(.location)
        }
        if shareInFbChanged() {
            editedFields.append(.share)
        }
        if initialListing.price.free != listing.price.free {
            editedFields.append(.freePosting)
        }
        return editedFields
    }

    private func shareInFbChanged() -> Bool {
        return shouldShareInFB // Initial state is false
    }
}


// MARK: - ProductCreateValidationError helper

private enum ProductCreateValidationError: Error {
    case network
    case internalError
    case noImages
    case noTitle
    case noPrice
    case noDescription
    case longDescription
    case noCategory
    case serverError(code: Int?)

    init(repoError: RepositoryError) {
        switch repoError {
        case .internalError:
            self = .internalError
        case .network:
            self = .network
        case .serverError, .notFound, .forbidden, .unauthorized, .tooManyRequests, .userNotVerified:
            self = .serverError(code: repoError.errorCode)
        }
    }

    var isFieldError: Bool {
        switch (self) {
        case .network, .internalError, .serverError:
            return false
        case .noImages, .noTitle, .noPrice, .noDescription, .longDescription, .noCategory:
            return true
        }
    }

    var description: String {
        switch self {
        case .network:
            return "network"
        case .internalError:
            return "internal"
        case .noImages:
            return "no images present"
        case .noTitle:
            return "no title"
        case .noPrice:
            return "invalid price"
        case .noDescription:
            return "no description"
        case .longDescription:
            return "description too long"
        case .noCategory:
            return "no category selected"
        case .serverError:
            return "internal server error"
        }
    }

    var errorMessage: String {
        switch (self) {
        case .network, .internalError, .serverError:
            return LGLocalizedString.editProductSendErrorUploadingProduct
        case .noImages:
            return LGLocalizedString.sellSendErrorInvalidImageCount
        case .noTitle:
            return LGLocalizedString.sellSendErrorInvalidTitle
        case .noPrice:
            return LGLocalizedString.sellSendErrorInvalidPrice
        case .noDescription:
            return LGLocalizedString.sellSendErrorInvalidDescription
        case .longDescription:
            return LGLocalizedString.sellSendErrorInvalidDescriptionTooLong(Constants.productDescriptionMaxLength)
        case .noCategory:
            return LGLocalizedString.sellSendErrorInvalidCategory
        }
    }
}
