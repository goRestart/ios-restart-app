//
//  EditProductViewModel.swift
//  LetGo
//
//  Created by DÃ­dac on 23/07/15.
//  Copyright (c) 2015 Ambatana. All rights reserved.
//

import FBSDKShareKit
import LGCoreKit
import Result
import RxSwift



enum TitleDisclaimerStatus {
    case Completed  // title autogenerated and selected
    case Ready      // no title yet, just received an autogenerated one
    case Loading    // no title, waiting for response
    case Clean      // user edits title
}

protocol EditProductViewModelDelegate : BaseViewModelDelegate {
    func vmDidSelectCategoryWithName(categoryName: String)
    func vmShouldUpdateDescriptionWithCount(count: Int)
    func vmDidAddOrDeleteImage()
    func vmShouldOpenMapWithViewModel(locationViewModel: EditLocationViewModel)
    func vmShareOnFbWith(content content: FBSDKShareLinkContent)
    func vmHideKeyboard()
}

enum EditProductImageType {
    case Local(image: UIImage)
    case Remote(file: File)
}

class ProductImages {
    var images: [EditProductImageType] = []
    var localImages: [UIImage] {
        return images.flatMap {
            switch $0 {
            case .Local(let image):
                return image
            case .Remote:
                return nil
            }
        }
    }
    var remoteImages: [File] {
        return images.flatMap {
            switch $0 {
            case .Local:
                return nil
            case .Remote(let file):
                return file
            }
        }
    }

    func append(image: UIImage) {
        images.append(.Local(image: image))
    }

    func append(file: File) {
        images.append(.Remote(file: file))
    }

    func removeAtIndex(index: Int) {
        images.removeAtIndex(index)
    }
}

class EditProductViewModel: BaseViewModel, EditLocationDelegate {

    // real time cloudsight
    let proposedTitle = Variable<String>("")
    let titleDisclaimerStatus = Variable<TitleDisclaimerStatus>(.Completed)
    private var userIsEditingTitle: Bool
    private var hasTitle: Bool {
        return (title != nil && title != "")
    }
    private var productIsNew: Bool {
        guard let creationDate = initialProduct.createdAt else { return true }
        return creationDate.isNewerThan(Constants.cloudsightTimeThreshold)
    }
    private var shouldAskForAutoTitle: Bool {
        // we ask for title if the product has less than 1h (or doesn't has creation date)
        // AND doesn't has one, or the user is editing the field
        return (!hasTitle || userIsEditingTitle) && productIsNew
    }
    private var requestTitleTimer: NSTimer?

    // Input
    var title: String? {
        didSet {
            checkChanges()
        }
    }
    var currency: Currency?
    var price: String? {
        didSet {
            checkChanges()
        }
    }
    var postalAddress: PostalAddress?
    var location: LGLocationCoordinates2D? {
        didSet {
            checkChanges()
        }
    }
    var category: ProductCategory? {
        didSet {
            checkChanges()
        }
    }
    var shouldShareInFB: Bool
    let maxImageCount = Constants.maxImageCount
    var descr: String? {
        didSet {
            checkChanges()
            delegate?.vmShouldUpdateDescriptionWithCount(descriptionCharCount)
        }
    }


    // Rx in-out
    let isFreePosting =  Variable<Bool>(false)

    // Rx output
    let titleAutogenerated = Variable<Bool>(false)
    let titleAutotranslated = Variable<Bool>(false)
    let locationInfo = Variable<String>("")
    let loadingProgress = Variable<Float?>(nil)
    let saveButtonEnabled = Variable<Bool>(false)

    // Data
    var productImages: ProductImages
    var images: [EditProductImageType] {
        return productImages.images
    }
    private let initialProduct: Product
    private var savedProduct: Product?
    private var categories: [ProductCategory] = []
    private var shouldTrack: Bool = true
    
    // Repositories
    let myUserRepository: MyUserRepository
    let productRepository: ProductRepository
    let categoryRepository: CategoryRepository
    let locationManager: LocationManager
    let commercializerRepository: CommercializerRepository
    let tracker: Tracker
    let featureFlags: FeatureFlaggeable

    // Delegate
    weak var delegate: EditProductViewModelDelegate?
    var closeCompletion: ((Product?) -> Void)?

    // Rx
    let disposeBag = DisposeBag()

    
    // MARK: - Lifecycle
    
    convenience init(product: Product) {
        let myUserRepository = Core.myUserRepository
        let productRepository = Core.productRepository
        let categoryRepository = Core.categoryRepository
        let locationManager = Core.locationManager
        let commercializerRepository = Core.commercializerRepository
        let tracker = TrackerProxy.sharedInstance
        let featureFlags = FeatureFlags.sharedInstance
        self.init(myUserRepository: myUserRepository, productRepository: productRepository,
                  categoryRepository: categoryRepository, locationManager: locationManager,
                  commercializerRepository: commercializerRepository, tracker: tracker, product: product,
                  featureFlags: featureFlags)
    }
    
    init(myUserRepository: MyUserRepository, productRepository: ProductRepository, categoryRepository: CategoryRepository,
         locationManager: LocationManager, commercializerRepository: CommercializerRepository, tracker: Tracker,
         product: Product, featureFlags: FeatureFlaggeable) {
        self.myUserRepository = myUserRepository
        self.productRepository = productRepository
        self.categoryRepository = categoryRepository
        self.locationManager = locationManager
        self.commercializerRepository = commercializerRepository
        self.tracker = tracker
        self.featureFlags = featureFlags
        self.initialProduct = product

        self.title = product.title
        
        self.titleAutotranslated.value = product.isTitleAutoTranslated(Core.countryHelper)
        self.titleAutogenerated.value = product.isTitleAutoGenerated

        self.proposedTitle.value = product.nameAuto ?? ""
        self.userIsEditingTitle = false

        self.price = String.fromPriceDouble(product.price.value)

        currency = product.currency
        if let descr = product.description {
            self.descr = descr
        }

        self.postalAddress = product.postalAddress
        self.location = product.location

        self.locationInfo.value = product.postalAddress.zipCodeCityString ?? ""

        self.category = product.category

        self.productImages = ProductImages()
        for file in product.images { productImages.append(file) }

        self.shouldShareInFB = myUserRepository.myUser?.facebookAccount != nil
        self.isFreePosting.value = featureFlags.freePostingModeAllowed && product.price.free
        super.init()

        setupCategories()
        setupRxBindings()
        trackStart()
    }

    override func didBecomeActive(firstTime: Bool) {
        super.didBecomeActive(firstTime)
        startTimer()
    }

    override func didBecomeInactive() {
        super.didBecomeInactive()
        stopTimer()
    }
    
    
    // MARK: - methods

    func closeButtonPressed() {
        if saveButtonEnabled.value {
            showCloseWChangesAlert()
        } else {
            closeEdit()
        }
    }

    var numberOfImages: Int {
        return images.count
    }
    
    func imageAtIndex(index: Int) -> EditProductImageType {
        return images[index]
    }
    
    var categoryName: String? {
        return category?.name
    }
    
    var descriptionCharCount: Int {
        guard let descr = descr else { return Constants.productDescriptionMaxLength }
        return Constants.productDescriptionMaxLength-descr.characters.count
    }
    
    func appendImage(image: UIImage) {
        productImages.append(image)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func deleteImageAtIndex(index: Int) {
        productImages.removeAtIndex(index)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func sendButtonPressed() {
        let error = validate()
        if let actualError = error {
            showError(actualError)
            trackValidationFailedWithError(actualError)
        } else {
            let loggedInAction: () -> Void = { [weak self] in self?.updateProduct() }
            delegate?.ifLoggedInThen(.Sell, loggedInAction: loggedInAction, elsePresentSignUpWithSuccessAction: loggedInAction)
        }
    }

    var fbShareContent: FBSDKShareLinkContent? {
        if let product = savedProduct {
            return ProductSocialMessage(product: product).fbShareContent
        }
        return nil
    }

    func openMap() {
        var shouldAskForPermission = true
        var permissionsActionBlock: ()->() = {}
        // check location enabled
        switch locationManager.locationServiceStatus {
        case let .Enabled(authStatus):
            switch authStatus {
            case .NotDetermined:
                shouldAskForPermission = true
                permissionsActionBlock = {  [weak self] in self?.locationManager.startSensorLocationUpdates() }
            case .Restricted, .Denied:
                shouldAskForPermission = true
                permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
            case .Authorized:
                shouldAskForPermission = false
            }
        case .Disabled:
            shouldAskForPermission = true
            permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
        }

        if shouldAskForPermission {
            // not enabled
            let okAction = UIAction(interface: UIActionInterface.StyledText(LGLocalizedString.commonOk,
                .Default), action: permissionsActionBlock)
            let alertIcon = UIImage(named: "ic_location_alert")
            delegate?.vmShowAlertWithTitle(LGLocalizedString.editProductLocationAlertTitle,
                                           text: LGLocalizedString.editProductLocationAlertText,
                                           alertType: .IconAlert(icon: alertIcon), actions: [okAction])
        } else {
            // enabled
            let initialPlace = Place(postalAddress: nil, location: locationManager.currentAutoLocation?.location)
            let locationVM = EditLocationViewModel(mode: .EditProductLocation, initialPlace: initialPlace)
            locationVM.locationDelegate = self
            delegate?.vmShouldOpenMapWithViewModel(locationVM)
        }
    }

    func fbSharingFinishedOk() {
        shouldTrack = true
        trackSharedFB()
        delay(0.25) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }

    func fbSharingFinishedWithError() {
        shouldTrack = true
        delay(0.25) { [weak self] in
            self?.delegate?.vmShowAutoFadingMessage(LGLocalizedString.sellSendErrorSharingFacebook) { [weak self] in
                self?.showSuccessMessageAndClose()
            }
        }
    }

    func fbSharingCancelled() {
        shouldTrack = true
        delay(0.25) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }


    // MARK: - Private methods

    private func startTimer() {
        guard shouldAskForAutoTitle else { return }
        requestTitleTimer = NSTimer.scheduledTimerWithTimeInterval(Constants.cloudsightRequestRepeatInterval, target: self,
                                                                   selector: #selector(getAutoGeneratedTitle),
                                                                   userInfo: nil, repeats: true)
        requestTitleTimer?.fire()
    }

    private func stopTimer() {
        requestTitleTimer?.invalidate()
    }

    private func setupRxBindings() {
        isFreePosting.asObservable().bindNext { [weak self] _ in self?.checkChanges() }.addDisposableTo(disposeBag)
    }

    private func checkChanges() {
        var hasChanges = false
        if productImages.localImages.count > 0 || initialProduct.images.count != productImages.remoteImages.count  {
            hasChanges = true
        }
        else if (initialProduct.name ?? "") != (title ?? "") {
            hasChanges = true
        }
        else if let priceString = price where initialProduct.price.value != Double(priceString) {
            hasChanges = true
        }
        else if (initialProduct.descr ?? "") != (descr ?? "") {
            hasChanges = true
        }
        else if initialProduct.category != category {
            hasChanges = true
        }
        else if initialProduct.location != location {
            hasChanges = true
        }
        else if initialProduct.price.free != isFreePosting.value {
            hasChanges = true
        }
        saveButtonEnabled.value = hasChanges
    }

    private func validate() -> ProductCreateValidationError? {
        
        if images.count < 1 {
            return .NoImages
        } else if descriptionCharCount < 0 {
            return .LongDescription
        } else if category == nil {
            return .NoCategory
        }
        return nil
    }

    private func updateProduct() {
        guard let category = category else {
            showError(.NoCategory)
            return
        }
        let name = title ?? ""
        let description = (descr ?? "").stringByRemovingEmoji()

        let priceAmount = isFreePosting.value && featureFlags.freePostingModeAllowed ? ProductPrice.Free : ProductPrice.Normal((price ?? "0").toPriceDouble())
        let currency = initialProduct.currency

        let editedProduct = productRepository.updateProduct(initialProduct, name: name, description: description,
                                                            price: priceAmount, currency: currency, location: location,
                                                            postalAddress: postalAddress, category: category)
        saveTheProduct(editedProduct, withImages: productImages)
    }
    
    private func saveTheProduct(product: Product, withImages images: ProductImages) {

        loadingProgress.value = 0
        
        let localImages = images.localImages
        let remoteImages = images.remoteImages
        
        let commonCompletion: ProductCompletion = { [weak self] result in
            guard let strongSelf = self else { return }
            strongSelf.loadingProgress.value = nil
            if let actualProduct = result.value {
                strongSelf.savedProduct = actualProduct
                strongSelf.trackComplete(actualProduct)
                strongSelf.finishedSaving()
            } else if let error = result.error {
                let newError = ProductCreateValidationError(repoError: error)
                strongSelf.showError(newError)
            }
        }

        let progressBlock: Float -> Void = { [weak self] progress in self?.loadingProgress.value = progress }
        
        if let _ = product.objectId {
            productRepository.update(product, oldImages: remoteImages, newImages: localImages, progress: progressBlock, completion: commonCompletion)
        } else {
            if localImages.isEmpty {
                productRepository.create(product, images: remoteImages, completion: commonCompletion)
            } else {
                productRepository.create(product, images: localImages, progress: progressBlock, completion: commonCompletion)
            }
        }
    }

    private func finishedSaving() {
        if let fbShareContent = fbShareContent where shouldShareInFB {
            shouldTrack = false
            delegate?.vmShareOnFbWith(content: fbShareContent)
        } else {
            showSuccessMessageAndClose()
        }
    }

    private func showSuccessMessageAndClose() {
        delegate?.vmShowAutoFadingMessage(LGLocalizedString.editProductSendOk) { [weak self] in
            self?.closeEdit()
        }
    }

    private func showCloseWChangesAlert() {
        let cancelAction = UIAction(
            interface: .Button(LGLocalizedString.commonCancel, .Secondary(fontSize: .Medium, withBorder: true)),
            action: {})
        let discardAction = UIAction(
            interface: .Button(LGLocalizedString.editProductUnsavedChangesAlertOk, .Primary(fontSize: .Medium)),
            action: { [weak self] in
                self?.closeEdit()
        })

        delegate?.vmHideKeyboard()
        delegate?.vmShowAlertWithTitle(nil, text: LGLocalizedString.editProductUnsavedChangesAlert,
                                       alertType: .PlainAlert, actions: [cancelAction, discardAction])
    }

    private func closeEdit() {
        delegate?.vmHideKeyboard()
        delegate?.vmDismiss { [weak self] in
            self?.closeCompletion?(self?.savedProduct)
        }
    }

    private func showError(error: ProductCreateValidationError) {
        var completion: ((Void) -> Void)? = nil
        if !error.isFieldError {
            shouldTrack = false
            completion = { [weak self] in self?.shouldTrack = true }
        }
        delegate?.vmShowAutoFadingMessage(error.errorMessage, completion: completion)
    }

    private func openLocationAppSettings() {
        guard let settingsURL = NSURL(string:UIApplicationOpenSettingsURLString) else { return }
        UIApplication.sharedApplication().openURL(settingsURL)
    }
}


// MARK: - Categories

extension EditProductViewModel {

    var numberOfCategories: Int {
        return categories.count
    }

    func categoryNameAtIndex(index: Int) -> String {
        guard 0..<categories.count ~= index else { return "" }
        return categories[index].name
    }

    func selectCategoryAtIndex(index: Int) {
        guard 0..<categories.count ~= index else { return }
        category = categories[index]
        delegate?.vmDidSelectCategoryWithName(category?.name ?? "")
    }

    private func setupCategories() {
        categoryRepository.index(filterVisible: true) { [weak self] result in
            guard let categories = result.value else { return }
            self?.categories = categories
        }
    }
}


// MARK: - EditLocationDelegate

extension EditProductViewModel {
    func editLocationDidSelectPlace(place: Place) {
        location = place.location
        postalAddress = place.postalAddress
        locationInfo.value = place.postalAddress?.zipCodeCityString ?? ""
    }
}


// MARK: - Cloudsight in real time

extension EditProductViewModel {
    dynamic func getAutoGeneratedTitle() {
        guard let productId = initialProduct.objectId where shouldAskForAutoTitle else {
            stopTimer()
            return
        }
        titleDisclaimerStatus.value = .Loading
        productRepository.retrieve(productId) { [weak self] result in
            if let value = result.value {
                guard let proposedTitle = value.nameAuto else { return }
                self?.stopTimer()
                self?.titleDisclaimerStatus.value = .Ready
                self?.proposedTitle.value = proposedTitle
            }
        }
    }

    /**
     Method called when the title textfield gets the focus
     */
    func userWritesTitle(text: String?) {
        guard productIsNew else { return }
        userIsEditingTitle = true
        titleAutotranslated.value = false
        titleAutogenerated.value = false
        titleDisclaimerStatus.value = proposedTitle.value.isEmpty ? .Loading : .Ready
    }

    func userFinishedEditingTitle(text: String) {
        guard productIsNew else { return }
        if text.isEmpty {
            titleLeftBlank()
        } else if text == proposedTitle.value {
            titleAutotranslated.value = true
            titleAutogenerated.value = true
            titleDisclaimerStatus.value = .Completed
        } else {
            titleAutotranslated.value = false
            titleAutogenerated.value = false
            titleDisclaimerStatus.value = proposedTitle.value.isEmpty ? .Loading : .Ready
        }
    }

    /**
     Method called when the title textfield loses the focus, and is empty
     */
    func titleLeftBlank() {
        guard productIsNew else { return }
        userIsEditingTitle = false
        titleDisclaimerStatus.value = proposedTitle.value.isEmpty ? .Loading : .Ready
    }

    /**
     Method called when the user presses the suggested title button
     */
    func userSelectedSuggestedTitle() {
        titleAutotranslated.value = true
        titleAutogenerated.value = true
        titleDisclaimerStatus.value = .Completed
    }
}


// MARK: - Trackings

extension EditProductViewModel {

    private func trackStart() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditStart(myUser, product: initialProduct)
        trackEvent(event)
    }

    private func trackValidationFailedWithError(error: ProductCreateValidationError) {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditFormValidationFailed(myUser, product: initialProduct,
                                                                 description: error.description)
        trackEvent(event)
    }

    private func trackSharedFB() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditSharedFB(myUser, product: savedProduct)
        trackEvent(event)
    }

    private func trackComplete(product: Product) {
        // if nothing is changed, we don't track the edition
        let editedFields = editFieldsComparedTo(product)
        guard !editedFields.isEmpty  else { return }

        let myUser = myUserRepository.myUser
        let event = TrackerEvent.productEditComplete(myUser, product: product, category: category,
                                                     editedFields: editedFields)
        trackEvent(event)
    }

    private func trackEvent(event: TrackerEvent) {
        if shouldTrack {
            tracker.trackEvent(event)
        }
    }

    private func editFieldsComparedTo(product: Product) -> [EventParameterEditedFields] {
        var editedFields: [EventParameterEditedFields] = []

        if productImages.localImages.count > 0 || initialProduct.images.count != productImages.remoteImages.count  {
            editedFields.append(.Picture)
        }
        if (initialProduct.name ?? "") != (product.name ?? "") {
            editedFields.append(.Title)
        }
        if initialProduct.priceString() != product.priceString() {
            editedFields.append(.Price)
        }
        if (initialProduct.descr ?? "") != (product.descr ?? "") {
            editedFields.append(.Description)
        }
        if initialProduct.category != product.category {
            editedFields.append(.Category)
        }
        if initialProduct.location != product.location {
            editedFields.append(.Location)
        }
        if shareInFbChanged() {
            editedFields.append(.Share)
        }
        if initialProduct.price.free != product.price.free {
            editedFields.append(.FreePosting)
        }
        return editedFields
    }

    private func shareInFbChanged() -> Bool {
        let fbLogin = myUserRepository.myUser?.facebookAccount != nil
        return fbLogin != shouldShareInFB
    }
}


// MARK: - ProductCreateValidationError helper

private enum ProductCreateValidationError: ErrorType {
    case Network
    case Internal
    case NoImages
    case NoTitle
    case NoPrice
    case NoDescription
    case LongDescription
    case NoCategory
    case ServerError(code: Int?)

    init(repoError: RepositoryError) {
        switch repoError {
        case .Internal:
            self = .Internal
        case .Network:
            self = .Network
        case .ServerError, .NotFound, .Forbidden, .Unauthorized, .TooManyRequests, .UserNotVerified:
            self = ServerError(code: repoError.errorCode)
        }
    }

    var isFieldError: Bool {
        switch (self) {
        case .Network, .Internal, .ServerError:
            return false
        case .NoImages, .NoTitle, .NoPrice, .NoDescription, .LongDescription, .NoCategory:
            return true
        }
    }

    var description: String {
        switch self {
        case Network:
            return "network"
        case Internal:
            return "internal"
        case NoImages:
            return "no images present"
        case NoTitle:
            return "no title"
        case NoPrice:
            return "invalid price"
        case NoDescription:
            return "no description"
        case LongDescription:
            return "description too long"
        case NoCategory:
            return "no category selected"
        case .ServerError:
            return "internal server error"
        }
    }

    var errorMessage: String {
        switch (self) {
        case .Network, .Internal, .ServerError:
            return LGLocalizedString.editProductSendErrorUploadingProduct
        case .NoImages:
            return LGLocalizedString.sellSendErrorInvalidImageCount
        case .NoTitle:
            return LGLocalizedString.sellSendErrorInvalidTitle
        case .NoPrice:
            return LGLocalizedString.sellSendErrorInvalidPrice
        case .NoDescription:
            return LGLocalizedString.sellSendErrorInvalidDescription
        case .LongDescription:
            return LGLocalizedString.sellSendErrorInvalidDescriptionTooLong(Constants.productDescriptionMaxLength)
        case .NoCategory:
            return LGLocalizedString.sellSendErrorInvalidCategory
        }
    }
}
