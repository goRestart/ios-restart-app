import FBSDKShareKit
import LGCoreKit
import Result
import RxSwift
import LGComponents

enum TitleDisclaimerStatus {
    case completed  // title autogenerated and selected
    case ready      // no title yet, just received an autogenerated one
    case loading    // no title, waiting for response
    case clean      // user edits title
}

protocol EditListingViewModelDelegate : BaseViewModelDelegate {
    func vmShouldUpdateDescriptionWithCount(_ count: Int)
    func vmDidAddOrDeleteImage()
    func openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: CarAttributeSelectionViewModel)
    func openAttributesPicker(viewModel: ListingAttributePickerViewModel)
    func vmShouldOpenMapWithViewModel(_ locationViewModel: EditLocationViewModel)
    func vmShareOnFbWith(content: FBSDKShareLinkContent)
    func vmHideKeyboard()
}

enum EditListingMediaType {
    case local(image: UIImage)
    case remote(media: Media)
}

class ListingMedia {
    var media: [EditListingMediaType] = []
    var localImages: [UIImage] {
        return media.compactMap {
            switch $0 {
            case .local(let image):
                return image
            case .remote:
                return nil
            }
        }
    }
    var remoteMedia: [Media] {
        return media.compactMap {
            switch $0 {
            case .local:
                return nil
            case .remote(let media):
                return media
            }
        }
    }
    var remoteImages: [File] {
        return media.compactMap {
            switch $0 {
            case .local:
                return nil
            case .remote(let media):
                if media.type == .image {
                    return LGFile(id: media.objectId, url: media.outputs.image)
                } else {
                    return nil
                }
            }
        }
    }
    var remoteVideos: [Video] {
        return media.compactMap {
            switch $0 {
            case .local:
                return nil
            case .remote(let media):
                if media.type == .video, let path = media.outputs.video?.absoluteString {
                    return LGVideo(path: path, snapshot: media.snapshotId)
                } else {
                    return nil
                }
            }
        }
    }

    func append(_ image: UIImage) {
        media.append(.local(image: image))
    }

    func append(_ media: Media) {
        self.media.append(.remote(media: media))
    }

    func removeAtIndex(_ index: Int) {
        media.remove(at: index)
    }
}

class EditListingViewModel: BaseViewModel, EditLocationDelegate {

    struct BoostCellUI {
        static let boostLabelText: String = R.Strings.bumpUpBannerBoostText
        static let boostLabelTextColor: UIColor = .blackText
        static let boostLabelFont: UIFont = .systemBoldFont(size: 17)
        static let boostIcon: UIImage = R.Asset.Monetization.icExtraBoost.image
    }
	
	struct EditProductFeatureUI {
		static let editProductFeatureTextColor: UIColor = UIColor.primaryColor
		static let editProductFeatureFont: UIFont = UIFont.systemBoldFont(size: 15)
		static let editProductFeatureBoostIcon: UIImage = R.Asset.Monetization.icLightning.image
	}


    // real time cloudsight
    let proposedTitle = Variable<String>("")
    let titleDisclaimerStatus = Variable<TitleDisclaimerStatus>(.completed)
    fileprivate var userIsEditingTitle: Bool
    fileprivate var hasTitle: Bool {
        return (title != nil && title != "")
    }
    fileprivate var isRealEstate: Bool {
        return category.value == .realEstate
    }
    fileprivate var disclaimerStatus: TitleDisclaimerStatus {
        if isRealEstate {
            return .clean
        } else {
            return proposedTitle.value.isEmpty ? .loading : .ready
        }
    }
    fileprivate var listingIsNew: Bool {
        guard let creationDate = initialListing.createdAt else { return true }
        return creationDate.isNewerThan(SharedConstants.cloudsightTimeThreshold)
    }
    fileprivate var shouldAskForAutoTitle: Bool {
        // we ask for title if the product has less than 1h (or doesn't has creation date)
        // AND doesn't has one, or the user is editing the field
        // AND it is not real estate
        return (!hasTitle || userIsEditingTitle) && listingIsNew && !isRealEstate
    }
    fileprivate var requestTitleTimer: Timer?

    // Input
    var title: String? {
        didSet {
            checkChanges()
        }
    }
    var currency: Currency?
    var price: String? {
        didSet {
            checkChanges()
        }
    }
    var postalAddress: PostalAddress?
    var location: LGLocationCoordinates2D? {
        didSet {
            checkChanges()
        }
    }
    var shouldShareInFB: Bool
    var maxImageCount: Int {
        return max(listingMedia.media.count, SharedConstants.maxImageCount)
    }
    var descr: String? {
        didSet {
            checkChanges()
            delegate?.vmShouldUpdateDescriptionWithCount(descriptionCharCount)
        }
    }

    private(set) var listingCanBeFeatured: Bool
    var featureLabelText: String? {
        return listingCanBeBoosted ? BoostCellUI.boostLabelText : featureFlags.bumpInEditCopys.variantString
    }
    var featureLabelTextColor: UIColor? {
        return listingCanBeBoosted ? BoostCellUI.boostLabelTextColor : EditProductFeatureUI.editProductFeatureTextColor
    }
    var featureLabelFont: UIFont? {
        return listingCanBeBoosted ? BoostCellUI.boostLabelFont : EditProductFeatureUI.editProductFeatureFont
    }
    var featureIcon: UIImage? {
        return listingCanBeBoosted ? BoostCellUI.boostIcon : EditProductFeatureUI.editProductFeatureBoostIcon
    }
    private let listingCanBeBoosted: Bool
    private let timeSinceLastBump: TimeInterval?
    private let maxCountdown: TimeInterval

    private let bumpUpProductData: BumpUpProductData?

    // Rx in-out
    let isFreePosting =  Variable<Bool>(false)
    let category = Variable<ListingCategory?>(nil)
    let carMakeId = Variable<String?>(nil)
    let carMakeName = Variable<String?>(nil)
    let carModelId = Variable<String?>(nil)
    let carModelName = Variable<String?>(nil)
    let carYear = Variable<Int?>(nil)
    let carBody = Variable<CarBodyType?>(nil)
    let carDistance = Variable<Int?>(nil)
    let carDistanceType = DistanceType.systemDistanceType()
    let carTransmission = Variable<CarTransmissionType?>(nil)
    let carFuel = Variable<CarFuelType?>(nil)
    let carDrivetrain = Variable<CarDriveTrainType?>(nil)
    let carSeat = Variable<CarSeat?>(nil)
    
    let realEstatePropertyType = Variable<RealEstatePropertyType?>(nil)
    let realEstateOfferType = Variable<RealEstateOfferType?>(nil)
    let realEstateNumberOfBedrooms = Variable<Int?>(nil)
    let realEstateNumberOfBathrooms = Variable<NumberOfBathrooms?>(nil)
    let realEstateNumberOfLivingRooms = Variable<Int?>(nil)
    let realEstateSizeSquareMeters = Variable<Int?>(nil)
    var realEstateNumberOfRooms = Variable<NumberOfRooms?>(nil)
    
    let serviceTypeId = Variable<String?>(nil)
    let serviceTypeName = Variable<String?>(nil)
    let serviceSubtypeId = Variable<String?>(nil)
    let serviceSubtypeName = Variable<String?>(nil)
    let servicePaymentFrequency = Variable<PaymentFrequency?>(nil)
    let serviceListingType = Variable<ServiceListingType?>(nil)
    
    var shouldFeatureItemAfterEdit = Variable<Bool>(true)
    
    // Rx output
    let titleAutogenerated = Variable<Bool>(false)
    let titleAutotranslated = Variable<Bool>(false)
    let locationInfo = Variable<String>("")
    let loadingProgress = Variable<Float?>(nil)
    let saveButtonEnabled = Variable<Bool>(false)

    // Data
    var listingMedia: ListingMedia
    var media: [EditListingMediaType] {
        return listingMedia.media
    }
    
    var realEstateSizeSquareMetersString: String? {
        guard let size = realEstateSizeSquareMeters.value else { return nil }
        return String(size)
    }
    
    fileprivate(set) var categories: [ListingCategory] = []
    fileprivate let initialListing: Listing
    fileprivate var savedListing: Listing?
    fileprivate var shouldTrack: Bool = true
    fileprivate var pageType: EventParameterTypePage?
    fileprivate var myUserId: String? {
        return myUserRepository.myUser?.objectId
    }
    fileprivate var myUserName: String? {
        return myUserRepository.myUser?.name
    }


    // Repositories
    private let myUserRepository: MyUserRepository
    private let listingRepository: ListingRepository
    private let fileRepository: FileRepository
    private let categoryRepository: CategoryRepository
    private let carsInfoRepository: CarsInfoRepository
    private let servicesInfoRepository: ServicesInfoRepository
    private let locationManager: LocationManager
    private let tracker: Tracker
    private let featureFlags: FeatureFlaggeable
    private let purchasesShopper: PurchasesShopper

    // Delegate
    weak var delegate: EditListingViewModelDelegate?
    var navigator: EditListingNavigator?

    // Rx
    let disposeBag = DisposeBag()
    
    
    // MARK: - Lifecycle
    
    convenience init(listing: Listing,
                     pageType: EventParameterTypePage?,
                     bumpUpProductData: BumpUpProductData?,
                     listingCanBeBoosted: Bool,
                     timeSinceLastBump: TimeInterval?,
                     maxCountdown: TimeInterval) {
        self.init(listing: listing,
                  pageType: pageType,
                  bumpUpProductData: bumpUpProductData,
                  myUserRepository: Core.myUserRepository,
                  listingRepository: Core.listingRepository,
                  fileRepository: Core.fileRepository,
                  categoryRepository: Core.categoryRepository,
                  carsInfoRepository: Core.carsInfoRepository,
                  servicesInfoRepository: Core.servicesInfoRepository,
                  locationManager: Core.locationManager,
                  tracker: TrackerProxy.sharedInstance,
                  featureFlags: FeatureFlags.sharedInstance,
                  listingCanBeBoosted: listingCanBeBoosted,
                  timeSinceLastBump: timeSinceLastBump,
                  maxCountdown: maxCountdown,
                  purchasesShopper: LGPurchasesShopper.sharedInstance)
    }
    
    init(listing: Listing,
         pageType: EventParameterTypePage?,
         bumpUpProductData: BumpUpProductData?,
         myUserRepository: MyUserRepository,
         listingRepository: ListingRepository,
         fileRepository: FileRepository,
         categoryRepository: CategoryRepository,
         carsInfoRepository: CarsInfoRepository,
         servicesInfoRepository: ServicesInfoRepository,
         locationManager: LocationManager,
         tracker: Tracker,
         featureFlags: FeatureFlaggeable,
         listingCanBeBoosted: Bool,
         timeSinceLastBump: TimeInterval?,
         maxCountdown: TimeInterval,
         purchasesShopper: PurchasesShopper) {
        self.myUserRepository = myUserRepository
        self.listingRepository = listingRepository
        self.fileRepository = fileRepository
        self.categoryRepository = categoryRepository
        self.carsInfoRepository = carsInfoRepository
        self.servicesInfoRepository = servicesInfoRepository
        self.locationManager = locationManager
        self.tracker = tracker
        self.featureFlags = featureFlags
        self.initialListing = listing
        self.purchasesShopper = purchasesShopper

        self.title = listing.title
        
        self.titleAutotranslated.value = listing.isTitleAutoTranslated(Core.countryHelper)
        self.titleAutogenerated.value = listing.isTitleAutoGenerated

        self.proposedTitle.value = listing.nameAuto ?? ""
        self.userIsEditingTitle = false

        self.price = listing.price.value > 0 ? String.fromPriceDouble(listing.price.value) : nil

        currency = listing.currency
        if let descr = listing.descr {
            self.descr = descr
        }

        self.postalAddress = listing.postalAddress
        self.location = listing.location

        self.locationInfo.value = listing.postalAddress.zipCodeCityString ?? ""

        self.category.value = listing.category

        self.listingMedia = ListingMedia()
        for media in listing.media { listingMedia.append(media) }

        switch listing {
        case .car(let car):
            let carMakeName = car.carAttributes.make ?? carsInfoRepository.retrieveMakeName(with: car.carAttributes.makeId)
            let carModelName = car.carAttributes.model ??
                carsInfoRepository.retrieveModelName(with: car.carAttributes.makeId, modelId: car.carAttributes.modelId)
            
            self.carMakeId.value = car.carAttributes.makeId
            self.carMakeName.value = carMakeName
            self.carModelId.value = car.carAttributes.modelId
            self.carModelName.value = carModelName
            self.carYear.value = car.carAttributes.year
            self.carDistance.value = car.carAttributes.mileage
            self.carBody.value = car.carAttributes.bodyType
            self.carTransmission.value = car.carAttributes.transmission
            self.carFuel.value = car.carAttributes.fuelType
            self.carDrivetrain.value = car.carAttributes.driveTrain
            self.carSeat.value = CarSeat(rawValue: car.carAttributes.seats ?? 0)
        case .product(_):
            break
        case .realEstate(let realEstate):
            self.realEstatePropertyType.value = realEstate.realEstateAttributes.propertyType
            self.realEstateOfferType.value = realEstate.realEstateAttributes.offerType
            self.realEstateNumberOfBedrooms.value = realEstate.realEstateAttributes.bedrooms
            
            if let bathrooms = realEstate.realEstateAttributes.bathrooms {
                self.realEstateNumberOfBathrooms.value = NumberOfBathrooms(rawValue: bathrooms)
            }
            
            self.realEstateNumberOfLivingRooms.value = realEstate.realEstateAttributes.livingRooms
            
            if let bedrooms = realEstate.realEstateAttributes.bedrooms, let livingRooms = realEstate.realEstateAttributes.livingRooms {
                self.realEstateNumberOfRooms.value = NumberOfRooms(numberOfBedrooms: bedrooms, numberOfLivingRooms: livingRooms)
            }
            self.realEstateSizeSquareMeters.value = realEstate.realEstateAttributes.sizeSquareMeters
        case .service(let services):
            if let serviceTypeId = services.servicesAttributes.typeId {
                self.serviceTypeId.value = serviceTypeId
                self.serviceTypeName.value = services.servicesAttributes.typeTitle
                    ?? servicesInfoRepository.serviceType(forServiceTypeId: serviceTypeId)?.name
            }
            if let serviceSubtypeId = services.servicesAttributes.subtypeId {
                self.serviceSubtypeId.value = serviceSubtypeId
                self.serviceSubtypeName.value = services.servicesAttributes.subtypeTitle
                    ?? servicesInfoRepository.serviceSubtype(forServiceSubtypeId: serviceSubtypeId)?.name
            }
            self.servicePaymentFrequency.value = services.servicesAttributes.paymentFrequency
            self.serviceListingType.value = services.servicesAttributes.listingType
        }

        self.shouldShareInFB = false
        self.isFreePosting.value = featureFlags.freePostingModeAllowed && listing.price.isFree
        self.pageType = pageType

        let listingHasPaymentInfo = bumpUpProductData?.hasPaymentId ?? false

        self.listingCanBeBoosted = listingCanBeBoosted
        self.timeSinceLastBump = timeSinceLastBump
        self.maxCountdown = maxCountdown

        var listingCanBeBumped = !(listing.featured ?? false)
        
        if let featured = listing.featured, !featured,
            let listingId = listing.objectId,
            let timeOfRecentBump = purchasesShopper.timeSinceRecentBumpFor(listingId: listingId) {
            listingCanBeBumped = !(timeOfRecentBump.timeDifference > 0.0)
        }

        self.listingCanBeFeatured = (listingCanBeBumped || listingCanBeBoosted) && listingHasPaymentInfo

        self.bumpUpProductData = bumpUpProductData
        
        super.init()

        setupCategories()
        setupRxBindings()
        trackStart()
    }

    override func didBecomeActive(_ firstTime: Bool) {
        super.didBecomeActive(firstTime)
    }

    override func didBecomeInactive() {
        super.didBecomeInactive()
        stopTimer()
    }
    
    
    // MARK: - methods

    func closeButtonPressed() {
        if saveButtonEnabled.value {
            showCloseWChangesAlert()
        } else {
            closeEdit()
        }
    }

    var numberOfMedia: Int {
        return media.count
    }
    
    func mediaAtIndex(_ index: Int) -> EditListingMediaType {
        return media[index]
    }
    
    var categoryName: String? {
        return category.value?.name
    }

    var carAttributes: CarAttributes {
        return CarAttributes(makeId: carMakeId.value,
                             make: carMakeName.value,
                             modelId: carModelId.value,
                             model: carModelName.value,
                             year: carYear.value,
                             mileage: carDistance.value,
                             mileageType: carDistanceType,
                             bodyType: carBody.value,
                             transmission: carTransmission.value,
                             fuelType: carFuel.value,
                             driveTrain: carDrivetrain.value,
                             seats: carSeat.value?.rawValue)
    }
    
    var realEstateAttributes: RealEstateAttributes {
        return RealEstateAttributes(propertyType: realEstatePropertyType.value,
                                    offerType: realEstateOfferType.value,
                                    bedrooms: realEstateNumberOfBedrooms.value,
                                    bathrooms: realEstateNumberOfBathrooms.value?.rawValue,
                                    livingRooms: realEstateNumberOfLivingRooms.value,
                                    sizeSquareMeters: realEstateSizeSquareMeters.value)
    }
    
    var servicesAttributes: ServiceAttributes {
        let paymentFrequencyValue: PaymentFrequency? = !(isFreePosting.value) ? servicePaymentFrequency.value : nil
        return ServiceAttributes(typeId: serviceTypeId.value,
                                 subtypeId: serviceSubtypeId.value,
                                 listingType: serviceListingType.value,
                                 typeTitle: serviceTypeName.value,
                                 subtypeTitle: serviceSubtypeName.value,
                                 paymentFrequency: paymentFrequencyValue)
    }

    var descriptionCharCount: Int {
        guard let descr = descr else { return SharedConstants.listingDescriptionMaxLength }
        return SharedConstants.listingDescriptionMaxLength-descr.count
    }
    
    func appendImage(_ image: UIImage) {
        listingMedia.append(image)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func deleteMediaAtIndex(_ index: Int) {
        listingMedia.removeAtIndex(index)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func sendButtonPressed() {
        let error = validate()
        if let actualError = error {
            showError(actualError)
            trackValidationFailedWithError(actualError)
        } else {
            updateListing(listing: initialListing)
        }
    }

    func carMakeButtonPressed() {
        // open car makes table
        let carsMakesList = carsInfoRepository.retrieveCarsMakes()
        let carsAttributtesChoiceVMWithMakes = CarAttributeSelectionViewModel(carsMakes: carsMakesList, selectedMake: carMakeId.value, style: .edit)
        carsAttributtesChoiceVMWithMakes.carAttributeSelectionDelegate = self
        delegate?.openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithMakes)
    }

    func carModelButtonPressed() {
        delegate?.vmHideKeyboard()
        guard let makeId = carMakeId.value else { return }
        let carsModelsList = carsInfoRepository.retrieveCarsModelsFormake(makeId: makeId)
        let carsAttributtesChoiceVMWithModels = CarAttributeSelectionViewModel(carsModels: carsModelsList, selectedModel: carModelId.value, style: .edit)
        carsAttributtesChoiceVMWithModels.carAttributeSelectionDelegate = self
        delegate?.openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithModels)
    }

    func carYearButtonPressed() {
        delegate?.vmHideKeyboard()
        let carsYearsList = carsInfoRepository.retrieveValidYears(withFirstYear: nil, ascending: false)
        let carsAttributtesChoiceVMWithYears = CarAttributeSelectionViewModel(yearsList: carsYearsList, selectedYear: carYear.value)
        carsAttributtesChoiceVMWithYears.carAttributeSelectionDelegate = self
        delegate?.openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithYears)
    }
    
    func carBodyButtonPressed() {
        openCarEditOption(selectedOption: carBody.value?.title, type: .body)
    }
    
    func carTransmissionButtonPressed() {
        openCarEditOption(selectedOption: carTransmission.value?.title, type: .transmission)
    }
    
    func carFuelButtonPressed() {
        openCarEditOption(selectedOption: carFuel.value?.title, type: .fuel)
    }
    
    func carDrivetrainButtonPressed() {
        openCarEditOption(selectedOption: carDrivetrain.value?.title, type: .drivetrain)
    }
    
    func carSeatButtonPressed() {
        openCarEditOption(selectedOption: carDrivetrain.value?.title, type: .seat)
    }
    
    private func openCarEditOption(selectedOption: String?, type: CarDetailType) {
        
        delegate?.vmHideKeyboard()
        
        guard let options = type.options else { return }
        
        let vm = ListingAttributeSingleSelectPickerViewModel(title: type.navigationTitle,
                                                             attributes: options,
                                                             selectedAttribute: selectedOption) { [weak self] selectedIndex in
            guard let selectedIndex = selectedIndex else { return }
            self?.didSelect(index: selectedIndex, type: type)
        }
        
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstatePropertyTypeButtonPressed() {
        let attributeValues = RealEstatePropertyType.allValues(postingFlowType: featureFlags.postingFlowType)
        let values = attributeValues.map { $0.localizedString }
        let vm = ListingAttributeSingleSelectPickerViewModel(
            title: R.Strings.realEstateTypePropertyTitle,
            attributes: values,
            selectedAttribute: realEstatePropertyType.value?.localizedString
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstatePropertyType.value = attributeValues[selectedIndex]
            } else {
                self?.realEstatePropertyType.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateOfferTypeButtonPressed() {
        let attributeValues = RealEstateOfferType.allValues
        let values = attributeValues.map { $0.localizedString }
        let vm = ListingAttributeSingleSelectPickerViewModel(
            title: R.Strings.realEstateOfferTypeTitle,
            attributes: values,
            selectedAttribute: realEstateOfferType.value?.localizedString
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstateOfferType.value = attributeValues[selectedIndex]
            } else {
                self?.realEstateOfferType.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateNumberOfBedroomsButtonPressed() {
        let attributeValues = NumberOfBedrooms.allValues
        let values = attributeValues.map { $0.localizedString }
        var selectedAttribute: String? = nil
        if let bedrooms = realEstateNumberOfBedrooms.value, let numberOfBedrooms = NumberOfBedrooms(rawValue: bedrooms) {
            selectedAttribute = numberOfBedrooms.localizedString
        }
        let vm = ListingAttributeSingleSelectPickerViewModel(
            title: R.Strings.realEstateBedroomsTitle,
            attributes: values,
            selectedAttribute: selectedAttribute
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstateNumberOfBedrooms.value = attributeValues[selectedIndex].rawValue
            } else {
                self?.realEstateNumberOfBedrooms.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateNumberOfRoomsButtonPressed() {
        let attributeValues = NumberOfRooms.allValues
        let values: [String] = attributeValues.compactMap { $0.localizedString }
        var selectedAttribute: String? = nil
        if let bedrooms = realEstateNumberOfBedrooms.value, let livingRooms = realEstateNumberOfLivingRooms.value {
            selectedAttribute = NumberOfRooms(numberOfBedrooms: bedrooms,
                          numberOfLivingRooms: livingRooms).localizedString
        }
        
        let selectionUpdateblock: ((Int?) -> Void) = { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                let numberOfRooms = NumberOfRooms(numberOfBedrooms: attributeValues[selectedIndex].numberOfBedrooms, numberOfLivingRooms: attributeValues[selectedIndex].numberOfLivingRooms)
                self?.realEstateNumberOfBedrooms.value = numberOfRooms.numberOfBedrooms
                self?.realEstateNumberOfLivingRooms.value = numberOfRooms.numberOfLivingRooms
            } else {
                self?.realEstateNumberOfRooms.value = nil
            }
        }
        let vm = ListingAttributeSingleSelectPickerViewModel(title: R.Strings.realEstateRoomsTitle,
                                                 attributes: values,
                                                 selectedAttribute: selectedAttribute,
                                                 selectionUpdate: selectionUpdateblock)
        
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateNumberOfBathroomsButtonPressed() {
        let attributeValues = NumberOfBathrooms.allValues
        let values = attributeValues.map { $0.localizedString }
        var selectedAttribute: String? = nil
        if let bathrooms = realEstateNumberOfBathrooms.value {
            selectedAttribute = bathrooms.localizedString
        }
        let vm = ListingAttributeSingleSelectPickerViewModel(
            title: R.Strings.realEstateBathroomsTitle,
            attributes: values,
            selectedAttribute: selectedAttribute
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstateNumberOfBathrooms.value = attributeValues[selectedIndex]
            } else {
                self?.realEstateNumberOfBathrooms.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateSizeEditionFinished(value: String) {
        realEstateSizeSquareMeters.value = Int(value)
    }

    func openMap() {
        var shouldAskForPermission = true
        var permissionsActionBlock: ()->() = {}
        // check location enabled
        switch locationManager.locationServiceStatus {
        case let .enabled(authStatus):
            switch authStatus {
            case .notDetermined:
                shouldAskForPermission = true
                permissionsActionBlock = {  [weak self] in self?.locationManager.startSensorLocationUpdates() }
            case .restricted, .denied:
                shouldAskForPermission = true
                permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
            case .authorizedAlways, .authorizedWhenInUse:
                shouldAskForPermission = false
            }
        case .disabled:
            shouldAskForPermission = true
            permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
        }

        if shouldAskForPermission {
            // not enabled
            let okAction = UIAction(interface: UIActionInterface.styledText(R.Strings.commonOk,
                .standard), action: permissionsActionBlock)
            let alertIcon = R.Asset.IconsButtons.icLocationAlert.image
            delegate?.vmShowAlertWithTitle(R.Strings.editProductLocationAlertTitle,
                                           text: R.Strings.editProductLocationAlertText,
                                           alertType: .iconAlert(icon: alertIcon), actions: [okAction])
        } else {
            // enabled
            let initialPlace = Place(postalAddress: nil, location: locationManager.currentAutoLocation?.location)
            let locationVM = EditLocationViewModel(mode: .editListingLocation, initialPlace: initialPlace, distanceRadius: nil)
            locationVM.locationDelegate = self
            delegate?.vmShouldOpenMapWithViewModel(locationVM)
        }
    }

    func fbSharingFinishedOk() {
        shouldTrack = true
        trackSharedFB()
        delay(SharedConstants.fbSdkRequiredDelay) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }

    func fbSharingFinishedWithError() {
        shouldTrack = true
        delay(SharedConstants.fbSdkRequiredDelay) { [weak self] in
            self?.delegate?.vmShowAutoFadingMessage(R.Strings.sellSendErrorSharingFacebook) { [weak self] in
                self?.showSuccessMessageAndClose()
            }
        }
    }

    func fbSharingCancelled() {
        shouldTrack = true
        delay(SharedConstants.fbSdkRequiredDelay) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }


    // MARK: - Private methods

    private func startTimer() {
        guard shouldAskForAutoTitle else { return }
        requestTitleTimer = Timer.scheduledTimer(timeInterval: SharedConstants.cloudsightRequestRepeatInterval,
                                                 target: self,
                                                 selector: #selector(getAutoGeneratedTitle),
                                                 userInfo: nil, repeats: true)
        requestTitleTimer?.fire()
    }

    fileprivate func stopTimer() {
        requestTitleTimer?.invalidate()
    }
    
    private func setupRxBindings() {
        setupChangeCheckingObservable()
        
        let bedroomsAndLivingRooms = Observable.combineLatest(realEstateNumberOfBedrooms.asObservable(), realEstateNumberOfLivingRooms.asObservable())
        
        bedroomsAndLivingRooms.bind { [weak self] (bedrooms, livingRooms) in
            guard let bedrooms = bedrooms, let livingRooms = livingRooms else { return }
            self?.realEstateNumberOfRooms.value = NumberOfRooms(numberOfBedrooms: bedrooms, numberOfLivingRooms: livingRooms)
        }.disposed(by: disposeBag)
    }

    private func setupChangeCheckingObservable() {
        let checkingCarChanges = Observable.combineLatest(isFreePosting.asObservable().distinctUntilChanged(),
                                                          category.asObservable().distinctUntilChanged(),
                                                          carMakeName.asObservable().distinctUntilChanged(),
                                                          carModelName.asObservable().distinctUntilChanged(),
                                                          carYear.asObservable().distinctUntilChanged())
        let checkingCarExtraFieldsChanges = Observable.combineLatest(carBody.asObservable().distinctUntilChanged(),
                                                          carFuel.asObservable().distinctUntilChanged(),
                                                          carDistance.asObservable().distinctUntilChanged(),
                                                          carTransmission.asObservable().distinctUntilChanged(),
                                                          carSeat.asObservable().distinctUntilChanged(),
                                                          carDrivetrain.asObservable().distinctUntilChanged())
        
        let checkingRealEstateChanges = Observable.combineLatest(realEstatePropertyType.asObservable().distinctUntilChanged(),
                                                                 realEstateOfferType.asObservable().distinctUntilChanged(),
                                                                 realEstateNumberOfBathrooms.asObservable().distinctUntilChanged(),
                                                                 realEstateNumberOfBedrooms.asObservable().distinctUntilChanged(),
                                                                 realEstateSizeSquareMeters.asObservable().distinctUntilChanged(),
                                                                 realEstateNumberOfLivingRooms.asObservable().distinctUntilChanged())
        let checkingServicesChanges = Observable.combineLatest(serviceTypeId.asObservable().distinctUntilChanged(),
                                                               serviceTypeName.asObservable().distinctUntilChanged(),
                                                               serviceListingType.asObservable().distinctUntilChanged(),
                                                               serviceSubtypeId.asObservable().distinctUntilChanged(),
                                                               serviceSubtypeName.asObservable().distinctUntilChanged(),
                                                               servicePaymentFrequency.asObservable().distinctUntilChanged())
        
        let checkAllChanges = Observable.combineLatest(checkingCarChanges.asObservable(),
                                                       checkingCarExtraFieldsChanges.asObservable(),
                                                       checkingRealEstateChanges.asObservable(),
                                                       checkingServicesChanges.asObservable())
        
        checkAllChanges.bind { [weak self] _ in
            self?.checkChanges()
            }.disposed(by: disposeBag)
        
    }
    
    private func checkChanges() {
        var hasChanges = false
        if listingMedia.localImages.count > 0 || initialListing.media.count != listingMedia.remoteMedia.count  {
            hasChanges = true
        }
        else if (initialListing.title ?? "") != (title ?? "") {
            hasChanges = true
        }
        else if initialListing.price.value != Double(price ?? "0") {
            hasChanges = true
        }
        else if (initialListing.descr ?? "") != (descr ?? "") {
            hasChanges = true
        }
        else if initialListing.category != category.value {
            hasChanges = true
        }
        else if initialListing.location != location {
            hasChanges = true
        }
        else if initialListing.price.isFree != isFreePosting.value {
            hasChanges = true
        }
        else if initialListing.isCar {
            hasChanges = initialListing.car?.carAttributes.updating(mileageType: carDistanceType) != carAttributes
        } else if initialListing.isRealEstate {
            hasChanges = initialListing.realEstate?.realEstateAttributes != realEstateAttributes
        } else if initialListing.isService {
            hasChanges = initialListing.service?.servicesAttributes != servicesAttributes
        }
        saveButtonEnabled.value = hasChanges
    }

    private func validate() -> ListingCreateValidationError? {
        if media.count < 1 {
            return .noImages
        } else if descriptionCharCount < 0 {
            return .longDescription
        } else if category.value == nil {
            return .noCategory
        }
        return nil
    }

    private func updateListing(listing: Listing) {
        guard let category = category.value else {
            showError(.noCategory)
            return
        }
        let editParams: ListingEditionParams
        switch category {
        case .unassigned, .electronics, .motorsAndAccessories, .sportsLeisureAndGames, .homeAndGarden,
             .moviesBooksAndMusic, .fashionAndAccesories, .babyAndChild, .other:
            guard let productEditParams = ProductEditionParams(listing: listing) else { return }
            productEditParams.category = category
            productEditParams.name = title ?? ""
            productEditParams.descr = (descr ?? "")
            productEditParams.price = generatePrice()
            if let updatedLocation = location, let updatedPostalAddress = postalAddress {
                productEditParams.location = updatedLocation
                productEditParams.postalAddress = updatedPostalAddress
            }
            editParams = .product(productEditParams)
        case .cars:
            guard let carEditParams = CarEditionParams(listing: listing) else { return }
            carEditParams.carAttributes = carAttributes
            carEditParams.category = .cars
            carEditParams.name = generateCarTitle()
            carEditParams.descr = (descr ?? "")
            carEditParams.price = generatePrice()

            if let updatedLocation = location, let updatedPostalAddress = postalAddress {
                carEditParams.location = updatedLocation
                carEditParams.postalAddress = updatedPostalAddress
            }
            editParams = .car(carEditParams)
        case .realEstate:
            guard let realEstateEditParams = RealEstateEditionParams(listing: listing) else { return }
            realEstateEditParams.realEstateAttributes = realEstateAttributes
            realEstateEditParams.category = category
            realEstateEditParams.name = title ?? ""
            realEstateEditParams.descr = (descr ?? "")
            realEstateEditParams.price = generatePrice()
            if let updatedLocation = location, let updatedPostalAddress = postalAddress {
                realEstateEditParams.location = updatedLocation
                realEstateEditParams.postalAddress = updatedPostalAddress
            }
            editParams = .realEstate(realEstateEditParams)
        case .services:
            guard let servicesEditParams = ServicesEditionParams(listing: listing) else { return }
            servicesEditParams.serviceAttributes = servicesAttributes
            servicesEditParams.category = .services
            servicesEditParams.name = title ?? ""
            servicesEditParams.descr = (descr ?? "")
            servicesEditParams.price = generatePrice()
            if let updatedLocation = location, let updatedPostalAddress = postalAddress {
                servicesEditParams.location = updatedLocation
                servicesEditParams.postalAddress = updatedPostalAddress
            }
            editParams = .service(servicesEditParams)
        }

        delegate?.vmHideKeyboard()
        loadingProgress.value = 0

        let localImages = listingMedia.localImages
        let remoteImages = listingMedia.remoteImages
        let remoteVideos = listingMedia.remoteVideos
        let videoSnapshots: [File] = listingMedia.remoteVideos.compactMap { video in
            return listing.images.first(where: { $0.objectId == video.snapshot })
        }
        
        fileRepository.upload(localImages, progress: { [weak self] in self?.loadingProgress.value = $0 }) {
            [weak self] imagesResult in
            if let newImages = imagesResult.value {
                
                guard let strongSelf = self else { return }
                let updatedParams = editParams.updating(images: newImages + remoteImages + videoSnapshots)
                    .updating(videos: remoteVideos)

                strongSelf.listingRepository.update(listingParams: updatedParams,
                                                    completion: { result in
                                                        self?.loadingProgress.value = nil
                                                        if let responseListing = result.value {
                                                            self?.savedListing = responseListing
                                                            self?.trackComplete(responseListing)
                                                            self?.finishedSaving()
                                                        } else if let error = result.error {
                                                            self?.trackError(errorDescription: error.localizedDescription,
                                                                             forListing: self?.initialListing)
                                                            self?.showError(ListingCreateValidationError(repoError: error))
                                                        }
                })
            } else if let error = imagesResult.error {
                self?.trackError(errorDescription: error.localizedDescription,
                           forListing: self?.initialListing)
                self?.showError(ListingCreateValidationError(repoError: error))
            }
        }
    }

    private func generateCarTitle() -> String {
        // title generate always but when there is already a title.
        guard let title = title, !title.isEmpty else {
            return carAttributes.generatedTitle
        }
        return title
    }

    private func generatePrice() -> ListingPrice {
        guard !(isFreePosting.value && featureFlags.freePostingModeAllowed) else { return .free }
        guard let actualPrice = price else { return .normal(0.0) }
        let priceValue = actualPrice.toPriceDouble()
        return .normal(priceValue)
    }

    private func finishedSaving() {
        guard let listing = savedListing, shouldShareInFB else { return showSuccessMessageAndClose() }
        let listingSocialMessage = ListingSocialMessage(listing: listing,
                                                        fallbackToStore: false,
                                                        myUserId: myUserId,
                                                        myUserName: myUserName)
        listingSocialMessage.retrieveFBShareContent { [weak self] fbShareContent in
            self?.shouldTrack = false
            self?.delegate?.vmShareOnFbWith(content: fbShareContent)
        }
    }

    private func showSuccessMessageAndClose() {
        delegate?.vmShowAutoFadingMessage(R.Strings.editProductSendOk) { [weak self] in
            self?.closeEdit()
        }
    }

    private func showCloseWChangesAlert() {
        let cancelAction = UIAction(
            interface: .button(R.Strings.commonCancel, .secondary(fontSize: .medium, withBorder: true)),
            action: {})
        let discardAction = UIAction(
            interface: .button(R.Strings.editProductUnsavedChangesAlertOk, .primary(fontSize: .medium)),
            action: { [weak self] in
                self?.closeEdit()
        })

        delegate?.vmHideKeyboard()
        delegate?.vmShowAlertWithTitle(nil, text: R.Strings.editProductUnsavedChangesAlert,
                                       alertType: .plainAlertOld, actions: [cancelAction, discardAction])
    }

    private func closeEdit() {
        delegate?.vmHideKeyboard()
        delegate?.vmDismiss { [weak self] in
            guard let strongSelf = self else { return }
            guard let editedListing = strongSelf.savedListing else {
                strongSelf.navigator?.editingListingDidCancel()
                return
            }
            let showBumpItem = strongSelf.shouldFeatureItemAfterEdit.value && strongSelf.listingCanBeFeatured

            let bumpUpProductData = showBumpItem ? strongSelf.bumpUpProductData : nil

            self?.navigator?.editingListingDidFinish(editedListing,
                                                     bumpUpProductData: bumpUpProductData,
                                                     timeSinceLastBump: strongSelf.timeSinceLastBump,
                                                     maxCountdown: strongSelf.maxCountdown)
        }
    }

    private func showError(_ error: ListingCreateValidationError) {
        var completion: (() -> Void)? = nil
        if !error.isFieldError {
            shouldTrack = false
            completion = { [weak self] in self?.shouldTrack = true }
        }
        delegate?.vmShowAutoFadingMessage(error.errorMessage, completion: completion)
    }

    private func openLocationAppSettings() {
        guard let settingsURL = URL(string:UIApplicationOpenSettingsURLString) else { return }
        UIApplication.shared.openURL(settingsURL)
    }
}


// MARK:- Services
extension EditListingViewModel {
    
    var paymentFrequencyText: String {
        return servicePaymentFrequency.value?.localizedDisplayName ?? R.Strings.editPaymentFrequencyPlaceholder
    }
    
    var shouldShowPaymentFrequency: Bool {
        return featureFlags.servicesPaymentFrequency.isActive && !(isFreePosting.value)
    }
    
    var shouldShowListingType: Bool {
        return featureFlags.jobsAndServicesEnabled.isActive
    }
    
    var serviceTypeTitleText: String {
        return shouldShowListingType ? R.Strings.editJobsServicesServiceTypeTitle : R.Strings.servicesServiceTypeTitle
    }
    
    var serviceSubtypeTitleText: String {
        return shouldShowListingType ? R.Strings.editJobsServicesServiceSubtypeTitle : R.Strings.servicesServiceSubtypeTitle
    }
    
    func serviceTypeButtonPressed() {
        let serviceTypes = servicesInfoRepository.retrieveServiceTypes()
        let serviceTypeNames = serviceTypes.map( { $0.name } )
        let selectedServiceType = serviceTypeName.value
        
        let vm = ListingAttributeSingleSelectPickerViewModel(title: R.Strings.servicesServiceTypeListTitle,
                                                 attributes: serviceTypeNames,
                                                 selectedAttribute: selectedServiceType) { [weak self] selectedIndex in
                                                    if let selectedIndex = selectedIndex {
                                                        self?.updateServiceType(withServiceType: serviceTypes[safeAt: selectedIndex])
                                                    } else {
                                                        self?.clearServiceType()
                                                    }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func serviceSubtypeButtonPressed() {
        guard let serviceTypeId = serviceTypeId.value else {
            return
        }
        
        let serviceSubtypes = servicesInfoRepository.serviceSubtypes(forServiceTypeId: serviceTypeId)
        let serviceSubtypeNames = serviceSubtypes.map( { $0.name } )
        let selectedServiceSubtype = serviceSubtypeName.value
        
        let vm = ListingAttributeSingleSelectPickerViewModel(title: R.Strings.servicesServiceSubtypeListTitle,
                                                             attributes: serviceSubtypeNames,
                                                             selectedAttribute: selectedServiceSubtype,
                                                             canSearchAttributes: true)
        { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.updateServiceSubtype(withServiceSubtype: serviceSubtypes[safeAt: selectedIndex])
            } else {
                self?.clearServiceSubtype()
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func paymentFrequencyButtonPressed() {
        let paymentFrequencyActions = PaymentFrequency.allCases.map({ [weak self] paymentFrequency in
            return UIAction(interface: UIActionInterface.text(paymentFrequency.localizedDisplayName),
                             action: {
                                self?.servicePaymentFrequency.value = paymentFrequency
            })
        })
        
        let cancelAction = UIAction(interface: UIActionInterface.text(R.Strings.commonCancel),
                                    action: {})

        delegate?.vmShowActionSheet(cancelAction,
                                    actions: paymentFrequencyActions,
                                    withTitle: R.Strings.editPriceTypeChooseTitle)
    }
    
    func serviceListingTypeButtonPressed() {
        let listingTypes = ServiceListingType.allCases
        let listingTypeNames = listingTypes.map( { $0.pluralDisplayName } )
        let selectedListingType = serviceListingType.value?.pluralDisplayName
        
        let vm = ListingAttributeSingleSelectPickerViewModel(title: R.Strings.editJobsServicesListingTypeTitle,
                                                             attributes: listingTypeNames,
                                                             selectedAttribute: selectedListingType) { [weak self] selectedIndex in
                                                                if let selectedIndex = selectedIndex {
                                                                    self?.updateListingType(withListingType: listingTypes[selectedIndex])
                                                                }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }

    private func updateServiceType(withServiceType serviceType: ServiceType?) {
        clearServiceSubtype()
        
        serviceTypeName.value = serviceType?.name
        serviceTypeId.value = serviceType?.id
    }
    
    private func updateServiceSubtype(withServiceSubtype serviceSubtype: ServiceSubtype?) {
        serviceSubtypeName.value = serviceSubtype?.name
        serviceSubtypeId.value = serviceSubtype?.id
    }
    
    private func updateListingType(withListingType listingType: ServiceListingType?) {
        serviceListingType.value = listingType
    }
    
    private func clearServiceType() {
        updateServiceType(withServiceType: nil)
    }
    
    private func clearServiceSubtype() {
        updateServiceSubtype(withServiceSubtype: nil)
    }
}


// MARK: - Categories

extension EditListingViewModel {

    var numberOfCategories: Int {
        return categories.count
    }
    
    func categoryNameAtIndex(_ index: Int) -> String {
        guard 0..<categories.count ~= index else { return "" }
        return categories[index].name
    }

    func selectCategoryAtIndex(_ index: Int) {
        guard 0..<categories.count ~= index else { return }
        category.value = categories[index]
    }

    fileprivate func setupCategories() {
        categoryRepository.index(servicesIncluded: false,
                                 carsIncluded: true,
                                 realEstateIncluded: featureFlags.realEstateEnabled.isActive) { [weak self] result in
                                    
            guard let categories = result.value else { return }
            self?.categories = categories
        }
    }
}


// MARK: - EditLocationDelegate

extension EditListingViewModel {
    func editLocationDidSelectPlace(_ place: Place, distanceRadius: Int?) {
        location = place.location
        postalAddress = place.postalAddress
        locationInfo.value = place.postalAddress?.zipCodeCityString ?? ""
    }
}

// MARK: - CarAttributeSelectionDelegate

extension EditListingViewModel : CarAttributeSelectionDelegate {
    func didSelectMake(makeId: String, makeName: String) {
        carMakeId.value = makeId
        carMakeName.value = makeName
        carModelId.value = nil
        carModelName.value = nil
    }

    func didSelectModel(modelId: String, modelName: String) {
        carModelId.value = modelId
        carModelName.value = modelName
    }

    func didSelectYear(year: Int) {
        carYear.value = year
    }
    
    func didSelect(index: Int, type: CarDetailType) {
        switch type {
        case .make, .model, .year, .distance:
            break
        case .body:
            carBody.value = CarBodyType.allCases[safeAt: index]
        case .transmission:
            carTransmission.value = CarTransmissionType.allCases[safeAt: index]
        case .fuel:
            carFuel.value = CarFuelType.allCases[safeAt: index]
        case .drivetrain:
            carDrivetrain.value = CarDriveTrainType.allCases[safeAt: index]
        case .seat:
            carSeat.value = CarSeat.allCases[safeAt: index]
        }
    }
}

// MARK: - Cloudsight in real time

extension EditListingViewModel {
    @objc func getAutoGeneratedTitle() {
        guard let productId = initialListing.objectId, shouldAskForAutoTitle else {
            stopTimer()
            return
        }
        titleDisclaimerStatus.value = .loading
        listingRepository.retrieve(productId) { [weak self] result in
            if let value = result.value {
                guard let proposedTitle = value.nameAuto else { return }
                self?.stopTimer()
                self?.titleDisclaimerStatus.value = .ready
                self?.proposedTitle.value = proposedTitle
            }
        }
    }

    /**
     Method called when the title textfield gets the focus
     */
    func userWritesTitle(_ text: String?) {
        guard listingIsNew else { return }
        userIsEditingTitle = true
        titleAutotranslated.value = false
        titleAutogenerated.value = false
        titleDisclaimerStatus.value = disclaimerStatus
    }

    func userFinishedEditingTitle(_ text: String) {
        guard listingIsNew else { return }
        if text.isEmpty {
            titleLeftBlank()
        } else if text == proposedTitle.value {
            titleAutotranslated.value = true
            titleAutogenerated.value = true
            titleDisclaimerStatus.value = .completed
        } else {
            titleAutotranslated.value = false
            titleAutogenerated.value = false
            titleDisclaimerStatus.value = disclaimerStatus
        }
    }

    /**
     Method called when the title textfield loses the focus, and is empty
     */
    func titleLeftBlank() {
        guard listingIsNew else { return }
        userIsEditingTitle = false
        titleDisclaimerStatus.value = disclaimerStatus
    }

    /**
     Method called when the user presses the suggested title button
     */
    func userSelectedSuggestedTitle() {
        titleAutotranslated.value = true
        titleAutogenerated.value = true
        titleDisclaimerStatus.value = .completed
    }
}


// MARK: - Trackings

extension EditListingViewModel {

    fileprivate func trackStart() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditStart(myUser, listing: initialListing, pageType: pageType)
        trackEvent(event)
    }

    fileprivate func trackValidationFailedWithError(_ error: ListingCreateValidationError) {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditFormValidationFailed(myUser, listing: initialListing,
                                                                 description: error.description)
        trackEvent(event)
    }

    fileprivate func trackSharedFB() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditSharedFB(myUser, listing: savedListing)
        trackEvent(event)
    }

    fileprivate func trackComplete(_ listing: Listing) {
        // if nothing is changed, we don't track the edition
        let editedFields = editFieldsComparedTo(listing)
        guard !editedFields.isEmpty  else { return }

        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditComplete(myUser, listing: listing, category: category.value,
                                                     editedFields: editedFields, pageType: pageType)
        trackEvent(event)
    }

    private func trackError(errorDescription: String?,
                            forListing listing: Listing?) {

        let user = myUserRepository.myUser
        let event = TrackerEvent.listingEditError(user,
                                                  listing: listing,
                                                  errorDescription: errorDescription)
        
        trackEvent(event)
    }
    fileprivate func trackEvent(_ event: TrackerEvent) {
        if shouldTrack {
            tracker.trackEvent(event)
        }
    }

    fileprivate func editFieldsComparedTo(_ listing: Listing) -> [EventParameterEditedFields] {
        var editedFields: [EventParameterEditedFields] = []

        if listingMedia.localImages.count > 0 || initialListing.media.count != listingMedia.remoteMedia.count  {
            editedFields.append(.picture)
        }
        if (initialListing.name ?? "") != (listing.name ?? "") {
            editedFields.append(.title)
        }
        if initialListing.priceString(freeModeAllowed: featureFlags.freePostingModeAllowed) !=
            listing.priceString(freeModeAllowed: featureFlags.freePostingModeAllowed) {
            editedFields.append(.price)
        }
        if (initialListing.descr ?? "") != (listing.descr ?? "") {
            editedFields.append(.description)
        }
        if initialListing.category != listing.category {
            editedFields.append(.category)
            // listing was not car and now is a car
            // if it was a car and is not anymore, BI said NOT TO track changes in make, model and year
            if let carAttributes = listing.car?.carAttributes {
                if !carAttributes.isMakeEmpty {
                    editedFields.append(.make)
                }
                if !carAttributes.isModelEmpty {
                    editedFields.append(.model)
                }
                if !carAttributes.isYearEmpty {
                    editedFields.append(.year)
                }
            }
        }
        if initialListing.location != listing.location {
            editedFields.append(.location)
        }
        if shareInFbChanged() {
            editedFields.append(.share)
        }
        if initialListing.price.isFree != listing.price.isFree {
            editedFields.append(.freePosting)
        }
        if let carEdited = initialListing.car?.carAttributes.editedFieldsTracker(newCarAttributes: listing.car?.carAttributes) {
            editedFields.append(contentsOf: carEdited)
        }
        if let servicesEdit = initialListing.service?.servicesAttributes.editedFieldsTracker(newServicesAttributes: listing.service?.servicesAttributes) {
            editedFields.append(contentsOf: servicesEdit)
        }
        return editedFields
    }

    private func shareInFbChanged() -> Bool {
        return shouldShareInFB // Initial state is false
    }
}


// MARK: - ListingCreateValidationError helper

private enum ListingCreateValidationError: Error {
    case network
    case internalError
    case noImages
    case noTitle
    case noPrice
    case noDescription
    case longDescription
    case noCategory
    case serverError(code: Int?)

    init(repoError: RepositoryError) {
        switch repoError {
        case .internalError, .wsChatError:
            self = .internalError
        case .network:
            self = .network
        case .serverError, .notFound, .forbidden, .unauthorized, .tooManyRequests, .userNotVerified, .searchAlertError:
            self = .serverError(code: repoError.errorCode)
        }
    }

    var isFieldError: Bool {
        switch (self) {
        case .network, .internalError, .serverError:
            return false
        case .noImages, .noTitle, .noPrice, .noDescription, .longDescription, .noCategory:
            return true
        }
    }

    var description: String {
        switch self {
        case .network:
            return "network"
        case .internalError:
            return "internal"
        case .noImages:
            return "no images present"
        case .noTitle:
            return "no title"
        case .noPrice:
            return "invalid price"
        case .noDescription:
            return "no description"
        case .longDescription:
            return "description too long"
        case .noCategory:
            return "no category selected"
        case .serverError:
            return "internal server error"
        }
    }

    var errorMessage: String {
        switch (self) {
        case .network, .internalError, .serverError:
            return R.Strings.editProductSendErrorUploadingProduct
        case .noImages:
            return R.Strings.sellSendErrorInvalidImageCount
        case .noTitle:
            return R.Strings.sellSendErrorInvalidTitle
        case .noPrice:
            return R.Strings.sellSendErrorInvalidPrice
        case .noDescription:
            return R.Strings.sellSendErrorInvalidDescription
        case .longDescription:
            return R.Strings.sellSendErrorInvalidDescriptionTooLong(SharedConstants.listingDescriptionMaxLength)
        case .noCategory:
            return R.Strings.sellSendErrorInvalidCategory
        }
    }
}
