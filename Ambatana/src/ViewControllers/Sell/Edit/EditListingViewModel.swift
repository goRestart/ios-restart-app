//
//  EditListingViewModel.swift
//  LetGo
//
//  Created by DÃ­dac on 23/07/15.
//  Copyright (c) 2015 Ambatana. All rights reserved.
//

import FBSDKShareKit
import LGCoreKit
import Result
import RxSwift


enum TitleDisclaimerStatus {
    case completed  // title autogenerated and selected
    case ready      // no title yet, just received an autogenerated one
    case loading    // no title, waiting for response
    case clean      // user edits title
}

protocol EditListingViewModelDelegate : BaseViewModelDelegate {
    func vmShouldUpdateDescriptionWithCount(_ count: Int)
    func vmDidAddOrDeleteImage()
    func openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: CarAttributeSelectionViewModel)
    func vmShouldOpenMapWithViewModel(_ locationViewModel: EditLocationViewModel)
    func vmShareOnFbWith(content: FBSDKShareLinkContent)
    func vmHideKeyboard()
}

enum EditListingImageType {
    case local(image: UIImage)
    case remote(file: File)
}

class ListingImages {
    var images: [EditListingImageType] = []
    var localImages: [UIImage] {
        return images.flatMap {
            switch $0 {
            case .local(let image):
                return image
            case .remote:
                return nil
            }
        }
    }
    var remoteImages: [File] {
        return images.flatMap {
            switch $0 {
            case .local:
                return nil
            case .remote(let file):
                return file
            }
        }
    }

    func append(_ image: UIImage) {
        images.append(.local(image: image))
    }

    func append(_ file: File) {
        images.append(.remote(file: file))
    }

    func removeAtIndex(_ index: Int) {
        images.remove(at: index)
    }
}

class EditListingViewModel: BaseViewModel, EditLocationDelegate {

    struct BoostCellUI {
        static let boostLabelText: String = LGLocalizedString.bumpUpBannerBoostText
        static let boostLabelTextColor: UIColor = .blackText
        static let boostLabelFont: UIFont = .systemBoldFont(size: 17)
        static let boostIcon: UIImage = #imageLiteral(resourceName: "ic_extra_boost")
    }
	
	struct EditProductFeatureUI {
		static let editProductFeaturelabelText: String = LGLocalizedString.editProductFeatureLabelLongText
		static let editProductFeatureTextColor: UIColor = UIColor.primaryColor
		static let editProductFeatureFont: UIFont = UIFont.systemBoldFont(size: 15)
		static let editProductFeatureBoostIcon: UIImage = #imageLiteral(resourceName: "ic_lightning")
	}

    // real time cloudsight
    let proposedTitle = Variable<String>("")
    let titleDisclaimerStatus = Variable<TitleDisclaimerStatus>(.completed)
    fileprivate var userIsEditingTitle: Bool
    fileprivate var hasTitle: Bool {
        return (title != nil && title != "")
    }
    fileprivate var isRealEstate: Bool {
        return category.value == .realEstate
    }
    fileprivate var disclaimerStatus: TitleDisclaimerStatus {
        if isRealEstate {
            return .clean
        } else {
            return proposedTitle.value.isEmpty ? .loading : .ready
        }
    }
    fileprivate var listingIsNew: Bool {
        guard let creationDate = initialListing.createdAt else { return true }
        return creationDate.isNewerThan(Constants.cloudsightTimeThreshold)
    }
    fileprivate var shouldAskForAutoTitle: Bool {
        // we ask for title if the product has less than 1h (or doesn't has creation date)
        // AND doesn't has one, or the user is editing the field
        // AND it is not real estate
        return (!hasTitle || userIsEditingTitle) && listingIsNew && !isRealEstate
    }
    fileprivate var requestTitleTimer: Timer?

    // Input
    var title: String? {
        didSet {
            checkChanges()
        }
    }
    var currency: Currency?
    var price: String? {
        didSet {
            checkChanges()
        }
    }
    var postalAddress: PostalAddress?
    var location: LGLocationCoordinates2D? {
        didSet {
            checkChanges()
        }
    }
    var shouldShareInFB: Bool
    var maxImageCount: Int {
        return max(listingImages.images.count, Constants.maxImageCount)
    }
    var descr: String? {
        didSet {
            checkChanges()
            delegate?.vmShouldUpdateDescriptionWithCount(descriptionCharCount)
        }
    }

    private(set) var shouldShowFeatureListingCell: Bool
    var featureLabelText: String? {
        return listingCanBeBoosted ? BoostCellUI.boostLabelText : EditProductFeatureUI.editProductFeaturelabelText
    }
    var featureLabelTextColor: UIColor? {
        return listingCanBeBoosted ? BoostCellUI.boostLabelTextColor : EditProductFeatureUI.editProductFeatureTextColor
    }
    var featureLabelFont: UIFont? {
        return listingCanBeBoosted ? BoostCellUI.boostLabelFont : EditProductFeatureUI.editProductFeatureFont
    }
    var featureIcon: UIImage? {
        return listingCanBeBoosted ? BoostCellUI.boostIcon : EditProductFeatureUI.editProductFeatureBoostIcon
    }
    private let listingCanBeBoosted: Bool
    private let timeSinceLastBump: TimeInterval?
    private let maxCountdown: TimeInterval?

    private let bumpUpProductData: BumpUpProductData?

    // Rx in-out
    let isFreePosting =  Variable<Bool>(false)
    let category = Variable<ListingCategory?>(nil)
    let carMakeId = Variable<String?>(nil)
    let carMakeName = Variable<String?>(nil)
    let carModelId = Variable<String?>(nil)
    let carModelName = Variable<String?>(nil)
    let carYear = Variable<Int?>(nil)
    let realEstatePropertyType = Variable<RealEstatePropertyType?>(nil)
    let realEstateOfferType = Variable<RealEstateOfferType?>(nil)
    let realEstateNumberOfBedrooms = Variable<Int?>(nil)
    let realEstateNumberOfBathrooms = Variable<NumberOfBathrooms?>(nil)
    let realEstateNumberOfLivingRooms = Variable<Int?>(nil)
    let realEstateSizeSquareMeters = Variable<Int?>(nil)
    var realEstateNumberOfRooms = Variable<NumberOfRooms?>(nil)
    var shouldFeatureItemAfterEdit = Variable<Bool>(true)
    
    // Rx output
    let titleAutogenerated = Variable<Bool>(false)
    let titleAutotranslated = Variable<Bool>(false)
    let locationInfo = Variable<String>("")
    let loadingProgress = Variable<Float?>(nil)
    let saveButtonEnabled = Variable<Bool>(false)

    // Data
    var listingImages: ListingImages
    var images: [EditListingImageType] {
        return listingImages.images
    }
    
    var realEstateSizeSquareMetersString: String? {
        guard let size = realEstateSizeSquareMeters.value else { return nil }
        return String(size)
    }
    
    fileprivate(set) var categories: [ListingCategory] = []
    fileprivate let initialListing: Listing
    fileprivate var savedListing: Listing?
    fileprivate var shouldTrack: Bool = true
    fileprivate var pageType: EventParameterTypePage?
    fileprivate var myUserId: String? {
        return myUserRepository.myUser?.objectId
    }
    fileprivate var myUserName: String? {
        return myUserRepository.myUser?.name
    }


    // Repositories
    let myUserRepository: MyUserRepository
    let listingRepository: ListingRepository
    let fileRepository: FileRepository
    let categoryRepository: CategoryRepository
    let carsInfoRepository: CarsInfoRepository
    let locationManager: LocationManager
    let tracker: Tracker
    let featureFlags: FeatureFlaggeable

    // Delegate
    weak var delegate: EditListingViewModelDelegate?
    weak var navigator: EditListingNavigator?

    // Rx
    let disposeBag = DisposeBag()

    
    // MARK: - Lifecycle
    
    convenience init(listing: Listing,
                     pageType: EventParameterTypePage?,
                     bumpUpProductData: BumpUpProductData?,
                     listingCanBeBoosted: Bool,
                     timeSinceLastBump: TimeInterval?,
                     maxCountdown: TimeInterval?) {
        self.init(listing: listing,
                  pageType: pageType,
                  bumpUpProductData: bumpUpProductData,
                  myUserRepository: Core.myUserRepository,
                  listingRepository: Core.listingRepository,
                  fileRepository: Core.fileRepository,
                  categoryRepository: Core.categoryRepository,
                  carsInfoRepository: Core.carsInfoRepository,
                  locationManager: Core.locationManager,
                  tracker: TrackerProxy.sharedInstance,
                  featureFlags: FeatureFlags.sharedInstance,
                  listingCanBeBoosted: listingCanBeBoosted,
                  timeSinceLastBump: timeSinceLastBump,
                  maxCountdown: maxCountdown)
    }
    
    init(listing: Listing,
         pageType: EventParameterTypePage?,
         bumpUpProductData: BumpUpProductData?,
         myUserRepository: MyUserRepository,
         listingRepository: ListingRepository,
         fileRepository: FileRepository,
         categoryRepository: CategoryRepository,
         carsInfoRepository: CarsInfoRepository,
         locationManager: LocationManager,
         tracker: Tracker,
         featureFlags: FeatureFlaggeable,
         listingCanBeBoosted: Bool,
         timeSinceLastBump: TimeInterval?,
         maxCountdown: TimeInterval?) {
        self.myUserRepository = myUserRepository
        self.listingRepository = listingRepository
        self.fileRepository = fileRepository
        self.categoryRepository = categoryRepository
        self.carsInfoRepository = carsInfoRepository
        self.locationManager = locationManager
        self.tracker = tracker
        self.featureFlags = featureFlags
        self.initialListing = listing

        self.title = listing.title
        
        self.titleAutotranslated.value = listing.isTitleAutoTranslated(Core.countryHelper)
        self.titleAutogenerated.value = listing.isTitleAutoGenerated

        self.proposedTitle.value = listing.nameAuto ?? ""
        self.userIsEditingTitle = false

        self.price = listing.price.value > 0 ? String.fromPriceDouble(listing.price.value) : nil

        currency = listing.currency
        if let descr = listing.descr {
            self.descr = descr
        }

        self.postalAddress = listing.postalAddress
        self.location = listing.location

        self.locationInfo.value = listing.postalAddress.zipCodeCityString ?? ""

        self.category.value = listing.category

        self.listingImages = ListingImages()
        for file in listing.images { listingImages.append(file) }

        switch listing {
        case .car(let car):
            self.carMakeId.value = car.carAttributes.makeId
            self.carMakeName.value = car.carAttributes.make
            self.carModelId.value = car.carAttributes.modelId
            self.carModelName.value = car.carAttributes.model
            self.carYear.value = car.carAttributes.year
        case .product(_):
            break
        case .realEstate(let realEstate):
            self.realEstatePropertyType.value = realEstate.realEstateAttributes.propertyType
            self.realEstateOfferType.value = realEstate.realEstateAttributes.offerType
            self.realEstateNumberOfBedrooms.value = realEstate.realEstateAttributes.bedrooms
            
            if let bathrooms = realEstate.realEstateAttributes.bathrooms {
                self.realEstateNumberOfBathrooms.value = NumberOfBathrooms(rawValue: bathrooms)
            }
            
            self.realEstateNumberOfLivingRooms.value = realEstate.realEstateAttributes.livingRooms
            
            if let bedrooms = realEstate.realEstateAttributes.bedrooms, let livingRooms = realEstate.realEstateAttributes.livingRooms {
                self.realEstateNumberOfRooms.value = NumberOfRooms(numberOfBedrooms: bedrooms, numberOfLivingRooms: livingRooms)
            }
            self.realEstateSizeSquareMeters.value = realEstate.realEstateAttributes.sizeSquareMeters
            
        }

        self.shouldShareInFB = false
        self.isFreePosting.value = featureFlags.freePostingModeAllowed && listing.price.isFree
        self.pageType = pageType

        let listinghasPaymentInfo = bumpUpProductData?.hasPaymentId ?? false

        self.listingCanBeBoosted = listingCanBeBoosted
        self.timeSinceLastBump = timeSinceLastBump
        self.maxCountdown = maxCountdown

        let listingCanBeFeatured = !(listing.featured ?? false)

        self.shouldShowFeatureListingCell = (listingCanBeFeatured || listingCanBeBoosted) && listinghasPaymentInfo

        self.bumpUpProductData = bumpUpProductData
        
        super.init()

        setupCategories()
        setupRxBindings()
        trackStart()
    }

    override func didBecomeActive(_ firstTime: Bool) {
        super.didBecomeActive(firstTime)
    }

    override func didBecomeInactive() {
        super.didBecomeInactive()
        stopTimer()
    }
    
    
    // MARK: - methods

    func closeButtonPressed() {
        if saveButtonEnabled.value {
            showCloseWChangesAlert()
        } else {
            closeEdit()
        }
    }

    var numberOfImages: Int {
        return images.count
    }
    
    func imageAtIndex(_ index: Int) -> EditListingImageType {
        return images[index]
    }
    
    var categoryName: String? {
        return category.value?.name
    }

    var carAttributes: CarAttributes {
        return CarAttributes(makeId: carMakeId.value, make: carMakeName.value, modelId: carModelId.value,
                             model: carModelName.value, year: carYear.value)
    }
    
    var realEstateAttributes: RealEstateAttributes {
        return RealEstateAttributes(propertyType: realEstatePropertyType.value,
                                    offerType: realEstateOfferType.value,
                                    bedrooms: realEstateNumberOfBedrooms.value,
                                    bathrooms: realEstateNumberOfBathrooms.value?.rawValue,
                                    livingRooms: realEstateNumberOfLivingRooms.value,
                                    sizeSquareMeters: realEstateSizeSquareMeters.value)
    }

    var descriptionCharCount: Int {
        guard let descr = descr else { return Constants.listingDescriptionMaxLength }
        return Constants.listingDescriptionMaxLength-descr.count
    }
    
    func appendImage(_ image: UIImage) {
        listingImages.append(image)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func deleteImageAtIndex(_ index: Int) {
        listingImages.removeAtIndex(index)
        delegate?.vmDidAddOrDeleteImage()
        checkChanges()
    }

    func sendButtonPressed() {
        let error = validate()
        if let actualError = error {
            showError(actualError)
            trackValidationFailedWithError(actualError)
        } else {
            updateListing(listing: initialListing)
        }
    }

    func carMakeButtonPressed() {
        // open car makes table
        let carsMakesList = carsInfoRepository.retrieveCarsMakes()
        let carsAttributtesChoiceVMWithMakes = CarAttributeSelectionViewModel(carsMakes: carsMakesList, selectedMake: carMakeId.value, style: .edit)
        carsAttributtesChoiceVMWithMakes.carAttributeSelectionDelegate = self
        delegate?.openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithMakes)
    }

    func carModelButtonPressed() {
        // open car models table
        guard let makeId = carMakeId.value else { return }
        let carsModelsList = carsInfoRepository.retrieveCarsModelsFormake(makeId: makeId)
        let carsAttributtesChoiceVMWithModels = CarAttributeSelectionViewModel(carsModels: carsModelsList, selectedModel: carModelId.value, style: .edit)
        carsAttributtesChoiceVMWithModels.carAttributeSelectionDelegate = self
        delegate?.openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithModels)
    }

    func carYearButtonPressed() {
        // open car years table
        let carsYearsList = carsInfoRepository.retrieveValidYears(withFirstYear: nil, ascending: false)
        let carsAttributtesChoiceVMWithYears = CarAttributeSelectionViewModel(yearsList: carsYearsList, selectedYear: carYear.value)
        carsAttributtesChoiceVMWithYears.carAttributeSelectionDelegate = self
        delegate?.openCarAttributeSelectionsWithViewModel(attributesChoiceViewModel: carsAttributtesChoiceVMWithYears)
    }
    
    func realEstatePropertyTypeButtonPressed() {
        let attributeValues = RealEstatePropertyType.allValues(postingFlowType: featureFlags.postingFlowType)
        let values = attributeValues.map { $0.localizedString }
        let vm = ListingAttributePickerViewModel(
            title: LGLocalizedString.realEstateTypePropertyTitle,
            attributes: values,
            selectedAttribute: realEstatePropertyType.value?.localizedString
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstatePropertyType.value = attributeValues[selectedIndex]
            } else {
                self?.realEstatePropertyType.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateOfferTypeButtonPressed() {
        let attributeValues = RealEstateOfferType.allValues
        let values = attributeValues.map { $0.localizedString }
        let vm = ListingAttributePickerViewModel(
            title: LGLocalizedString.realEstateOfferTypeTitle,
            attributes: values,
            selectedAttribute: realEstateOfferType.value?.localizedString
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstateOfferType.value = attributeValues[selectedIndex]
            } else {
                self?.realEstateOfferType.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateNumberOfBedroomsButtonPressed() {
        let attributeValues = NumberOfBedrooms.allValues
        let values = attributeValues.map { $0.localizedString }
        var selectedAttribute: String? = nil
        if let bedrooms = realEstateNumberOfBedrooms.value, let numberOfBedrooms = NumberOfBedrooms(rawValue: bedrooms) {
            selectedAttribute = numberOfBedrooms.localizedString
        }
        let vm = ListingAttributePickerViewModel(
            title: LGLocalizedString.realEstateBedroomsTitle,
            attributes: values,
            selectedAttribute: selectedAttribute
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstateNumberOfBedrooms.value = attributeValues[selectedIndex].rawValue
            } else {
                self?.realEstateNumberOfBedrooms.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateNumberOfRoomsButtonPressed() {
        let attributeValues = NumberOfRooms.allValues
        let values: [String] = attributeValues.flatMap { $0.localizedString }
        var selectedAttribute: String? = nil
        if let bedrooms = realEstateNumberOfBedrooms.value, let livingRooms = realEstateNumberOfLivingRooms.value {
            selectedAttribute = NumberOfRooms(numberOfBedrooms: bedrooms,
                          numberOfLivingRooms: livingRooms).localizedString
        }
        
        let selectionUpdateblock: ((Int?) -> Void) = { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                let numberOfRooms = NumberOfRooms(numberOfBedrooms: attributeValues[selectedIndex].numberOfBedrooms, numberOfLivingRooms: attributeValues[selectedIndex].numberOfLivingRooms)
                self?.realEstateNumberOfBedrooms.value = numberOfRooms.numberOfBedrooms
                self?.realEstateNumberOfLivingRooms.value = numberOfRooms.numberOfLivingRooms
            } else {
                self?.realEstateNumberOfRooms.value = nil
            }
        }
        let vm = ListingAttributePickerViewModel(title: LGLocalizedString.realEstateRoomsTitle,
                                                 attributes: values,
                                                 selectedAttribute: selectedAttribute,
                                                 selectionUpdate: selectionUpdateblock)
        
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateNumberOfBathroomsButtonPressed() {
        let attributeValues = NumberOfBathrooms.allValues
        let values = attributeValues.map { $0.localizedString }
        var selectedAttribute: String? = nil
        if let bathrooms = realEstateNumberOfBathrooms.value {
            selectedAttribute = bathrooms.localizedString
        }
        let vm = ListingAttributePickerViewModel(
            title: LGLocalizedString.realEstateBathroomsTitle,
            attributes: values,
            selectedAttribute: selectedAttribute
        ) { [weak self] selectedIndex in
            if let selectedIndex = selectedIndex {
                self?.realEstateNumberOfBathrooms.value = attributeValues[selectedIndex]
            } else {
                self?.realEstateNumberOfBathrooms.value = nil
            }
        }
        navigator?.openListingAttributePicker(viewModel: vm)
    }
    
    func realEstateSizeEditionFinished(value: String) {
        realEstateSizeSquareMeters.value = Int(value)
    }

    func openMap() {
        var shouldAskForPermission = true
        var permissionsActionBlock: ()->() = {}
        // check location enabled
        switch locationManager.locationServiceStatus {
        case let .enabled(authStatus):
            switch authStatus {
            case .notDetermined:
                shouldAskForPermission = true
                permissionsActionBlock = {  [weak self] in self?.locationManager.startSensorLocationUpdates() }
            case .restricted, .denied:
                shouldAskForPermission = true
                permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
            case .authorizedAlways, .authorizedWhenInUse:
                shouldAskForPermission = false
            }
        case .disabled:
            shouldAskForPermission = true
            permissionsActionBlock = { [weak self] in self?.openLocationAppSettings() }
        }

        if shouldAskForPermission {
            // not enabled
            let okAction = UIAction(interface: UIActionInterface.styledText(LGLocalizedString.commonOk,
                .standard), action: permissionsActionBlock)
            let alertIcon = UIImage(named: "ic_location_alert")
            delegate?.vmShowAlertWithTitle(LGLocalizedString.editProductLocationAlertTitle,
                                           text: LGLocalizedString.editProductLocationAlertText,
                                           alertType: .iconAlert(icon: alertIcon), actions: [okAction])
        } else {
            // enabled
            let initialPlace = Place(postalAddress: nil, location: locationManager.currentAutoLocation?.location)
            let locationVM = EditLocationViewModel(mode: .editListingLocation, initialPlace: initialPlace, distanceRadius: nil)
            locationVM.locationDelegate = self
            delegate?.vmShouldOpenMapWithViewModel(locationVM)
        }
    }

    func fbSharingFinishedOk() {
        shouldTrack = true
        trackSharedFB()
        delay(Constants.fbSdkRequiredDelay) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }

    func fbSharingFinishedWithError() {
        shouldTrack = true
        delay(Constants.fbSdkRequiredDelay) { [weak self] in
            self?.delegate?.vmShowAutoFadingMessage(LGLocalizedString.sellSendErrorSharingFacebook) { [weak self] in
                self?.showSuccessMessageAndClose()
            }
        }
    }

    func fbSharingCancelled() {
        shouldTrack = true
        delay(Constants.fbSdkRequiredDelay) { [weak self] in
            self?.showSuccessMessageAndClose()
        }
    }


    // MARK: - Private methods

    private func startTimer() {
        guard shouldAskForAutoTitle else { return }
        requestTitleTimer = Timer.scheduledTimer(timeInterval: Constants.cloudsightRequestRepeatInterval,
                                                 target: self,
                                                 selector: #selector(getAutoGeneratedTitle),
                                                 userInfo: nil, repeats: true)
        requestTitleTimer?.fire()
    }

    fileprivate func stopTimer() {
        requestTitleTimer?.invalidate()
    }

    private func setupRxBindings() {
        let checkingCarChanges = Observable.combineLatest(isFreePosting.asObservable(),
                                                          category.asObservable(),
                                                          carMakeName.asObservable(),
                                                          carModelName.asObservable(),
                                                          carYear.asObservable())
        let checkingRealEstateChanges = Observable.combineLatest(realEstatePropertyType.asObservable(),
                                                                 realEstateOfferType.asObservable(),
                                                                 realEstateNumberOfBathrooms.asObservable(),
                                                                 realEstateNumberOfBedrooms.asObservable(),
                                                                 realEstateSizeSquareMeters.asObservable(),
                                                                 realEstateNumberOfLivingRooms.asObservable())
        let checkAllChanges = Observable.combineLatest(checkingCarChanges.asObservable(),
                                                       checkingRealEstateChanges.asObservable())
        checkAllChanges.asObservable().bind { [weak self] _ in
            self?.checkChanges()
        }.disposed(by: disposeBag)
        
        let bedroomsAndLivingRooms = Observable.combineLatest(realEstateNumberOfBedrooms.asObservable(), realEstateNumberOfLivingRooms.asObservable())
        
        bedroomsAndLivingRooms.asObservable().bind { [weak self] (bedrooms, livingRooms) in
            guard let bedrooms = bedrooms, let livingRooms = livingRooms else { return }
            self?.realEstateNumberOfRooms.value = NumberOfRooms(numberOfBedrooms: bedrooms, numberOfLivingRooms: livingRooms)
        }.disposed(by: disposeBag)
    }

    private func checkChanges() {
        var hasChanges = false
        if listingImages.localImages.count > 0 || initialListing.images.count != listingImages.remoteImages.count  {
            hasChanges = true
        }
        else if (initialListing.title ?? "") != (title ?? "") {
            hasChanges = true
        }
        else if initialListing.price.value != Double(price ?? "0") {
            hasChanges = true
        }
        else if (initialListing.descr ?? "") != (descr ?? "") {
            hasChanges = true
        }
        else if initialListing.category != category.value {
            hasChanges = true
        }
        else if initialListing.location != location {
            hasChanges = true
        }
        else if initialListing.price.isFree != isFreePosting.value {
            hasChanges = true
        }
        else if initialListing.isCar {
            hasChanges = initialListing.car?.carAttributes != carAttributes
        } else if initialListing.isRealEstate {
            hasChanges = initialListing.realEstate?.realEstateAttributes != realEstateAttributes
        }
        saveButtonEnabled.value = hasChanges
    }

    private func validate() -> ListingCreateValidationError? {
        if images.count < 1 {
            return .noImages
        } else if descriptionCharCount < 0 {
            return .longDescription
        } else if category.value == nil {
            return .noCategory
        }
        return nil
    }

    private func updateListing(listing: Listing) {
        guard let category = category.value else {
            showError(.noCategory)
            return
        }
        let editParams: ListingEditionParams
        switch category {
        case .unassigned, .electronics, .motorsAndAccessories, .sportsLeisureAndGames, .homeAndGarden,
             .moviesBooksAndMusic, .fashionAndAccesories, .babyAndChild, .other, .services:
            guard let productEditParams = ProductEditionParams(listing: listing) else { return }
            productEditParams.category = category
            productEditParams.name = title ?? ""
            productEditParams.descr = (descr ?? "")
            productEditParams.price = generatePrice()
            if let updatedLocation = location, let updatedPostalAddress = postalAddress {
                productEditParams.location = updatedLocation
                productEditParams.postalAddress = updatedPostalAddress
            }
            editParams = .product(productEditParams)
        case .cars:
            guard let carEditParams = CarEditionParams(listing: listing) else { return }
            carEditParams.carAttributes = carAttributes
            carEditParams.category = .cars
            carEditParams.name = generateCarTitle()
            carEditParams.descr = (descr ?? "")
            carEditParams.price = generatePrice()

            if let updatedLocation = location, let updatedPostalAddress = postalAddress {
                carEditParams.location = updatedLocation
                carEditParams.postalAddress = updatedPostalAddress
            }
            editParams = .car(carEditParams)
        case .realEstate:
            guard let realEstateEditParams = RealEstateEditionParams(listing: listing) else { return }
            realEstateEditParams.realEstateAttributes = realEstateAttributes
            realEstateEditParams.category = category
            realEstateEditParams.name = title ?? ""
            realEstateEditParams.descr = (descr ?? "")
            realEstateEditParams.price = generatePrice()
            if let updatedLocation = location, let updatedPostalAddress = postalAddress {
                realEstateEditParams.location = updatedLocation
                realEstateEditParams.postalAddress = updatedPostalAddress
            }
            editParams = .realEstate(realEstateEditParams)
        }

        delegate?.vmHideKeyboard()
        loadingProgress.value = 0

        let localImages = listingImages.localImages
        let remoteImages = listingImages.remoteImages
        
        fileRepository.upload(localImages, progress: { [weak self] in self?.loadingProgress.value = $0 }) {
            [weak self] imagesResult in
            if let newImages = imagesResult.value {
                
                guard let strongSelf = self else { return }
                let updatedParams = editParams.updating(images: remoteImages + newImages)
                let shouldUseCarEndpoint = strongSelf.featureFlags.createUpdateIntoNewBackend.shouldUseCarEndpoint(with: updatedParams)
                let updateAction = strongSelf.listingRepository.updateAction(shouldUseCarEndpoint)
                
                updateAction(updatedParams) { result in
                    self?.loadingProgress.value = nil
                    if let responseListing = result.value {
                        self?.savedListing = responseListing
                        self?.trackComplete(responseListing)
                        self?.finishedSaving()
                    } else if let error = result.error {
                        self?.showError(ListingCreateValidationError(repoError: error))
                    }
                }
            } else if let error = imagesResult.error {
                self?.showError(ListingCreateValidationError(repoError: error))
            }
        }
    }

    private func generateCarTitle() -> String {
        // title generate always but when there is already a title.
        guard let title = title, !title.isEmpty else {
            return carAttributes.generatedTitle
        }
        return title
    }

    private func generatePrice() -> ListingPrice {
        guard !(isFreePosting.value && featureFlags.freePostingModeAllowed) else { return .free }
        guard let actualPrice = price else { return .normal(0.0) }
        let priceValue = actualPrice.toPriceDouble()
        return .normal(priceValue)
    }

    private func finishedSaving() {
        guard let listing = savedListing, shouldShareInFB else { return showSuccessMessageAndClose() }
        let listingSocialMessage = ListingSocialMessage(listing: listing,
                                                        fallbackToStore: false,
                                                        myUserId: myUserId,
                                                        myUserName: myUserName)
        listingSocialMessage.retrieveFBShareContent { [weak self] fbShareContent in
            self?.shouldTrack = false
            self?.delegate?.vmShareOnFbWith(content: fbShareContent)
        }
    }

    private func showSuccessMessageAndClose() {
        delegate?.vmShowAutoFadingMessage(LGLocalizedString.editProductSendOk) { [weak self] in
            self?.closeEdit()
        }
    }

    private func showCloseWChangesAlert() {
        let cancelAction = UIAction(
            interface: .button(LGLocalizedString.commonCancel, .secondary(fontSize: .medium, withBorder: true)),
            action: {})
        let discardAction = UIAction(
            interface: .button(LGLocalizedString.editProductUnsavedChangesAlertOk, .primary(fontSize: .medium)),
            action: { [weak self] in
                self?.closeEdit()
        })

        delegate?.vmHideKeyboard()
        delegate?.vmShowAlertWithTitle(nil, text: LGLocalizedString.editProductUnsavedChangesAlert,
                                       alertType: .plainAlertOld, actions: [cancelAction, discardAction])
    }

    private func closeEdit() {
        delegate?.vmHideKeyboard()
        delegate?.vmDismiss { [weak self] in
            guard let editedListing = self?.savedListing else {
                self?.navigator?.editingListingDidCancel()
                return
            }
            let showBumpItem = self?.shouldFeatureItemAfterEdit.value ?? false

            let bumpUpProductData = showBumpItem ? self?.bumpUpProductData : nil

            self?.navigator?.editingListingDidFinish(editedListing,
                                                     bumpUpProductData: bumpUpProductData,
                                                     timeSinceLastBump: self?.timeSinceLastBump,
                                                     maxCountdown: self?.maxCountdown)
        }
    }

    private func showError(_ error: ListingCreateValidationError) {
        var completion: (() -> Void)? = nil
        if !error.isFieldError {
            shouldTrack = false
            completion = { [weak self] in self?.shouldTrack = true }
        }
        delegate?.vmShowAutoFadingMessage(error.errorMessage, completion: completion)
    }

    private func openLocationAppSettings() {
        guard let settingsURL = URL(string:UIApplicationOpenSettingsURLString) else { return }
        UIApplication.shared.openURL(settingsURL)
    }
}


// MARK: - Categories

extension EditListingViewModel {

    var numberOfCategories: Int {
        return categories.count
    }

    func categoryNameAtIndex(_ index: Int) -> String {
        guard 0..<categories.count ~= index else { return "" }
        return categories[index].name
    }

    func selectCategoryAtIndex(_ index: Int) {
        guard 0..<categories.count ~= index else { return }
        category.value = categories[index]
    }

    fileprivate func setupCategories() {
        categoryRepository.index(servicesIncluded: featureFlags.servicesCategoryEnabled.isActive,
                                 carsIncluded: true,
                                 realEstateIncluded: featureFlags.realEstateEnabled.isActive) { [weak self] result in
                                    
            guard let categories = result.value else { return }
            self?.categories = categories
        }
    }
}


// MARK: - EditLocationDelegate

extension EditListingViewModel {
    func editLocationDidSelectPlace(_ place: Place, distanceRadius: Int?) {
        location = place.location
        postalAddress = place.postalAddress
        locationInfo.value = place.postalAddress?.zipCodeCityString ?? ""
    }
}

// MARK: - CarAttributeSelectionDelegate

extension EditListingViewModel : CarAttributeSelectionDelegate {
    func didSelectMake(makeId: String, makeName: String) {
        carMakeId.value = makeId
        carMakeName.value = makeName
        carModelId.value = nil
        carModelName.value = nil
    }

    func didSelectModel(modelId: String, modelName: String) {
        carModelId.value = modelId
        carModelName.value = modelName
    }

    func didSelectYear(year: Int) {
        carYear.value = year
    }
}

// MARK: - Cloudsight in real time

extension EditListingViewModel {
    @objc func getAutoGeneratedTitle() {
        guard let productId = initialListing.objectId, shouldAskForAutoTitle else {
            stopTimer()
            return
        }
        titleDisclaimerStatus.value = .loading
        listingRepository.retrieve(productId) { [weak self] result in
            if let value = result.value {
                guard let proposedTitle = value.nameAuto else { return }
                self?.stopTimer()
                self?.titleDisclaimerStatus.value = .ready
                self?.proposedTitle.value = proposedTitle
            }
        }
    }

    /**
     Method called when the title textfield gets the focus
     */
    func userWritesTitle(_ text: String?) {
        guard listingIsNew else { return }
        userIsEditingTitle = true
        titleAutotranslated.value = false
        titleAutogenerated.value = false
        titleDisclaimerStatus.value = disclaimerStatus
    }

    func userFinishedEditingTitle(_ text: String) {
        guard listingIsNew else { return }
        if text.isEmpty {
            titleLeftBlank()
        } else if text == proposedTitle.value {
            titleAutotranslated.value = true
            titleAutogenerated.value = true
            titleDisclaimerStatus.value = .completed
        } else {
            titleAutotranslated.value = false
            titleAutogenerated.value = false
            titleDisclaimerStatus.value = disclaimerStatus
        }
    }

    /**
     Method called when the title textfield loses the focus, and is empty
     */
    func titleLeftBlank() {
        guard listingIsNew else { return }
        userIsEditingTitle = false
        titleDisclaimerStatus.value = disclaimerStatus
    }

    /**
     Method called when the user presses the suggested title button
     */
    func userSelectedSuggestedTitle() {
        titleAutotranslated.value = true
        titleAutogenerated.value = true
        titleDisclaimerStatus.value = .completed
    }
}


// MARK: - Trackings

extension EditListingViewModel {

    fileprivate func trackStart() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditStart(myUser, listing: initialListing, pageType: pageType)
        trackEvent(event)
    }

    fileprivate func trackValidationFailedWithError(_ error: ListingCreateValidationError) {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditFormValidationFailed(myUser, listing: initialListing,
                                                                 description: error.description)
        trackEvent(event)
    }

    fileprivate func trackSharedFB() {
        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditSharedFB(myUser, listing: savedListing)
        trackEvent(event)
    }

    fileprivate func trackComplete(_ listing: Listing) {
        // if nothing is changed, we don't track the edition
        let editedFields = editFieldsComparedTo(listing)
        guard !editedFields.isEmpty  else { return }

        let myUser = myUserRepository.myUser
        let event = TrackerEvent.listingEditComplete(myUser, listing: listing, category: category.value,
                                                     editedFields: editedFields, pageType: pageType)
        trackEvent(event)
    }

    fileprivate func trackEvent(_ event: TrackerEvent) {
        if shouldTrack {
            tracker.trackEvent(event)
        }
    }

    fileprivate func editFieldsComparedTo(_ listing: Listing) -> [EventParameterEditedFields] {
        var editedFields: [EventParameterEditedFields] = []

        if listingImages.localImages.count > 0 || initialListing.images.count != listingImages.remoteImages.count  {
            editedFields.append(.picture)
        }
        if (initialListing.name ?? "") != (listing.name ?? "") {
            editedFields.append(.title)
        }
        if initialListing.priceString(freeModeAllowed: featureFlags.freePostingModeAllowed) !=
            listing.priceString(freeModeAllowed: featureFlags.freePostingModeAllowed) {
            editedFields.append(.price)
        }
        if (initialListing.descr ?? "") != (listing.descr ?? "") {
            editedFields.append(.description)
        }
        if initialListing.category != listing.category {
            editedFields.append(.category)
            // listing was not car and now is a car
            // if it was a car and is not anymore, BI said NOT TO track changes in make, model and year
            if let carAttributes = listing.car?.carAttributes {
                if !carAttributes.isMakeEmpty {
                    editedFields.append(.make)
                }
                if !carAttributes.isModelEmpty {
                    editedFields.append(.model)
                }
                if !carAttributes.isYearEmpty {
                    editedFields.append(.year)
                }
            }
        }
        if initialListing.location != listing.location {
            editedFields.append(.location)
        }
        if shareInFbChanged() {
            editedFields.append(.share)
        }
        if initialListing.price.isFree != listing.price.isFree {
            editedFields.append(.freePosting)
        }
        // listing was a car and is still a car
        if let carAttributes = initialListing.car?.carAttributes, let newCarAttributes = listing.car?.carAttributes {
            if carAttributes.makeId != newCarAttributes.makeId {
                editedFields.append(.make)
            }
            if carAttributes.modelId != newCarAttributes.modelId {
                editedFields.append(.model)
            }
            if carAttributes.year != newCarAttributes.year {
                editedFields.append(.year)
            }
        }
        return editedFields
    }

    private func shareInFbChanged() -> Bool {
        return shouldShareInFB // Initial state is false
    }
}


// MARK: - ListingCreateValidationError helper

private enum ListingCreateValidationError: Error {
    case network
    case internalError
    case noImages
    case noTitle
    case noPrice
    case noDescription
    case longDescription
    case noCategory
    case serverError(code: Int?)

    init(repoError: RepositoryError) {
        switch repoError {
        case .internalError, .wsChatError:
            self = .internalError
        case .network:
            self = .network
        case .serverError, .notFound, .forbidden, .unauthorized, .tooManyRequests, .userNotVerified, .searchAlertError:
            self = .serverError(code: repoError.errorCode)
        }
    }

    var isFieldError: Bool {
        switch (self) {
        case .network, .internalError, .serverError:
            return false
        case .noImages, .noTitle, .noPrice, .noDescription, .longDescription, .noCategory:
            return true
        }
    }

    var description: String {
        switch self {
        case .network:
            return "network"
        case .internalError:
            return "internal"
        case .noImages:
            return "no images present"
        case .noTitle:
            return "no title"
        case .noPrice:
            return "invalid price"
        case .noDescription:
            return "no description"
        case .longDescription:
            return "description too long"
        case .noCategory:
            return "no category selected"
        case .serverError:
            return "internal server error"
        }
    }

    var errorMessage: String {
        switch (self) {
        case .network, .internalError, .serverError:
            return LGLocalizedString.editProductSendErrorUploadingProduct
        case .noImages:
            return LGLocalizedString.sellSendErrorInvalidImageCount
        case .noTitle:
            return LGLocalizedString.sellSendErrorInvalidTitle
        case .noPrice:
            return LGLocalizedString.sellSendErrorInvalidPrice
        case .noDescription:
            return LGLocalizedString.sellSendErrorInvalidDescription
        case .longDescription:
            return LGLocalizedString.sellSendErrorInvalidDescriptionTooLong(Constants.listingDescriptionMaxLength)
        case .noCategory:
            return LGLocalizedString.sellSendErrorInvalidCategory
        }
    }
}
